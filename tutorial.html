<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
        <meta name="description" content="The Lily Programming Language, tutorial">
        <meta name="author" content="Jesse Ray Adkins">

        <title>Lily Tutorial</title>

        <!-- Bootstrap core CSS -->
        <link href="css/bootstrap.min.css" rel="stylesheet">
        <!-- Bootstrap theme -->
        <link href="css/bootstrap-theme.min.css" rel="stylesheet">
        <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
        <link href="css/ie10-viewport-bug-workaround.css" rel="stylesheet">

        <link rel="stylesheet" href="css/theme.css">

        <script src="js/ie-emulation-modes-warning.js"></script>
    </head>

    <body role="document">
        <nav class="navbar navbar-inverse navbar-static-top">
            <div class="container">
                <div class="navbar-header">
                    <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="index.html">Lily</a>
                </div>
                <div id="navbar" class="navbar-collapse collapse">
                        <ul class="nav navbar-nav">
                            <li><a href="index.html">Home</a></li>
                            <li class="active"><a href="#">Tutorial</a></li>
                            <li><a href="reference.html">Reference</a></li>
                            <li><a href="packages.html">Packages</a></li>
                            <li><a href="sandbox.html">Sandbox</a></li>
                            <li><a href="http://github.com/jesserayadkins/lily">Github</a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </nav>

        <div class="container theme-showcase" role="main">
            <div class="col-md-6" style="width: 100%">
                <dl>
                    <dt>
                        <span>
                            <a href="#_Introduction">Introduction</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_Compiling">Compiling</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_SettingUp">Setting up mod_lily</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_StartingModes">Starting Modes</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_HelloWorld">Hello World</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_TheBasics">The Basics</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_Functions">Functions</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_BlockBasics">Block Basics</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_BlockTypes">Block Types</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_Expressions">Expressions</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_Classes">Classes</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_Exceptions">Exceptions</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_Lambdas">Lambdas</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_Generics">Generics</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_Enums">Enums</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_Dynamic">Dynamic</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_ImportAndUse">import and use</a>
                        </span>
                    </dt>
                    <dt>
                        <span>
                            <a href="#_WrappingUp">Wrapping up</a>
                        </span>
                    </dt>
                </dl>
            </div>
            <div class="section">
                <h1 id="_Introduction">
                    Introduction
                </h1>
                <p>
This tutorial will cover Lily's syntax, and show some idioms of the language.
Most examples here are small code snippets.
More detailed code samples can be found in the <a href="https://github.com/jesserayadkins/lily/tree/master/try">try/</a> directory of Lily's source code.
                </p>
            </div>
            <div class="section">
                <h1 id="_Compiling">
                    Compiling
                </h1>
                <p>
Before you can do anything with the language, you'll need to compile it.
To do that, you'll need <strong>CMake</strong> and a modern C compiler that supports C11 (both gcc and clang are fine).
                </p>
                <p>
A basic compile is just <code>cmake . ; make ; make install</code>.
This will install the executable for the language (<code>lily</code>).
To install <code>mod_lily</code>, you'll need Apache headers.
If you do, you can install <code>mod_lily</code> by adding <code>-DWITH_APACHE=on</code> to your <code>cmake</code> invocation.
                </p>
            </div>
            <div class="section">
                <h1 id="_SettingUp">
                    Setting up mod_lily
                </h1>
                <p>
This part is entirely optional. To begin with, you'll need Apache's development headers.
To build <code>mod_lily</code>, add <code>-DWITH_APACHE=on</code> to your CMake invocation, then <code>cmake ; make ; make install</code>.
This will build <code>mod_lily</code> and put it among Apache's library files.
                </p>
                <p>
Now you'll need to locate Apache's configuration file so that you can alter it.
Here's the additions that I made on my own server:
                </p>
                <pre>
# Near the module section:
LoadModule&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/usr/lib64/httpd/modules/mod_lily.so

# After cgi-bin...
&lt;Directory "/var/www/cgi-bin"&gt;
    SetHandler lily
&lt;/Directory&gt;</pre>
                <p>
Here's a script you can place into <code>/var/www/cgi-bin/</code> (or whatever directory you set aside) to make sure that the install is working.
                </p>
                <pre>
&lt;?lily
use server
?&gt;
&lt;html&gt;
&lt;body&gt;
&lt;?lily
server.write("Hello from mod_lily!")
?&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
            </div>
            <div class="section">
                <h1 id="_StartingModes">
                    Starting modes
                </h1>
                <p>
Lily has two different modes of execution: <code>standalone</code> and <code>template</code>.
The mode that is chosen determines how the first file is viewed.
                </p>
                <p>
In <code>standalone</code> mode, the first file seen is expected to just be code.
This is the default for the <code>lily</code> executable.
               </p>
               <p>
In <code>template</code> mode, the first file is scanned as text.
Code is denoted through <code>&lt;?lily ... &gt;</code> tags.
In addition, the file must start with a <code>&lt;?lily</code> tag (even if it's empty).
Doing so lets Lily know that the file isn't just code.
This is the default for the <code>mod_lily</code> executable.
You can also explicitly specify this through <code>lily -t</code>.
               </p>
               <p>
It is assumed that the examples in this tutorial will be run through <code>standalone</code> mode.
However, they will also work in <code>template</code> mode.
               </p>
            </div>
            <div class="section">
                <h1 id="_HelloWorld">
                    Hello World
                </h1>
                <p>
Let's start off with the simplest program.
Open a file, and call it <code>hello.lly</code>.
<code>.lly</code> is the extension that all Lily files use, regardless of the starting mode.
                </p>
                <pre>
print("Lily says hello!")</pre>
                <p>
Lily allows function calls to be outside of an explicit <code>main</code>-like function.
                </p>
            </div>
            <div class="section">
                <h1 id="_TheBasics">
                    The Basics
                </h1>
                <p>
Now that your environment has been established, let's get to business.
To begin with, here are some variable declarations:
                </p>
                <pre>
var ok = true
var age = 10
var name = "Jesse"
# You can explicitly set a type with `: type`, but it's not necessary.
var items: List[String] = ["Eggs", "Milk", "Bread"]
var prices = ["Hot Dog and Soda" =&gt; 1.50,
              "Rotisserie Chicken" =&gt; 4.99]
var bytes = B"\255\253\001\255\253\31"

# Tuples are &lt[...]&gt;
var record = &lt;[10, "20", [1, 2, 3]]&gt;</pre>
                <p>
These declarations show off a few of Lily's built-in classes:
<code>Boolean</code>, <code>Integer</code>, <code>ByteString</code>, <code>String</code>, <code>List</code>, <code>Hash</code>, and <code>Tuple</code>.
                </p>
                <p>
Most of these classes aren't going to be anything new for you.
<code>ByteString</code> and <code>String</code> are Lily's way of segmenting string-like data for you.
A <code>String</code> is guaranteed to be utf-8 compliant, and \0 terminated.
On the other hand, <code>ByteString</code> has neither of those guarantees, and operates as a bag of bytes.
                </p>
                <p>
There's also a mention of <code>List[String]</code>.
In Lily, the instantiations of generic types (except for <code>Function</code>) are denoted in square brackets.
In the above case, the type of the <code>Hash</code> is <code>Hash</code><span>[</span><code>String</code><span>, </span><code>Double</code><span>]</span> (key, then value).
The <code>Tuple</code> above has a long type: <code>Tuple[Integer, String, List[Integer]]</code>.
                </p>
                <p>
Lily has two kinds of classes built into it.
The above classes are all written into the interpreter as primitives, and thus have no constructors.
There are a few other classes built into Lily:
<code>Dynamic</code>, <code>Exception</code>, <code>Tainted</code>, <code>Option</code>, and <code>Either</code>.
Those classes will be covered later on.
                </p>
            </div>
            <div class="section">
                <h1 id="_Functions">
                    Functions
                </h1>
                <p>
Now that basic classes have been established, it's time to move on to <code>Function</code>s.
A new <code>Function</code> is created using the <code>define</code> keyword.
Here are some examples, along with their types.
                </p>
<pre>
# Function()
define do_nothing
{
    
}

# Function( =&gt; Integer)
define return_ten: Integer
{
    return 10
}

# Function(Integer, Integer =&gt; Integer)
define add(a: Integer, b: Integer): Integer
{
    return a + b
}

define multiply(a: Integer, b: Integer): Integer
{
    return a * b
}

# Functions are first-class:
var math_ops = ["+" =&gt; add, "*" =&gt; multiply]
math_ops["+"](10, 20) # 30

# Functions not created with define can be reassigned.
var math_fn = add
math_fn = multiply

# Function( =&gt; Function())
define return_no_op: Function()
{
    return do_nothing
}

return_no_op()()

# ...indicates a variable # of arguments.
# Function(Integer...) =&gt; Integer
define sum(numbers: Integer...): Integer
{
    var total = 0
    numbers.each{|e| total += e }
    return total
}

# sum() # 0
# sum(1, 2, 3) # 6

# Function(*Integer =&gt; Integer)
define optarg(a: *Integer = 10): Integer
{
    return a + 10
}

optarg(100) # 110
optarg() # 20

# Function(Integer =&gt; String)
var some_func = Integer.to_s
</pre>
                <p>
Now that creating new <code>Function</code>s has been covered, here's how to call them.
                </p>
                <pre>
var some_int = String.parse_i("123")
some_int = "123".parse_i
some_int = "123" |&gt; String.parse_i</pre>
                <p>
The <code>|&gt;</code> operator comes from F#. Put simply, <code>x |&gt; f</code> is equivalent to <code>f(x)</code>.
Here are some more examples:
                </p>
                <pre>
define square(x: Integer): Integer
{
    return x * x
}

var another_int = square(10)
another_int = 10 |&gt; square |&gt; square

var does_end = String.ends_with("needle", "e")
does_end = "needle".ends_with("e")
does_end = "e" |&gt; "needle".ends_with</pre>
            </div>
            <div class="section">
                <h1 id="_BlockBasics">
                    Block Basics
                </h1>
                <p>
Blocks are divided into two types: Those that allow multiple statements, and those that only allow a single statement.
                </p>
                <pre>
if age > 21:
    print("You're an adult!")
else:
    print("You're not an adult yet. Sorry!")</pre>
                <p>
Similar to Python, the conditional expressions are all terminated with the <code>:</code>.
While Lily does not use whitespace for indentation, it is still good practice to use consistent indentation.
Instead of whitespace, Lily uses a single brace to indicate if a condition can span multiple lines.
                </p>
                <pre>
var pass_count = 0, fail_count = 0
define check_test(result: Boolean, message: String)
{
    if result: {
        pass_count += 1
    else:
        fail_count += 1
        print($"Test ^(pass_count + fail_count) failed ^(message).\n")
    }
}</pre>
                <p>
Unlike most curly-brace family languages, Lily does not require a brace for each branch.
Instead, the presence of a brace means that all branches span multiple expressions.
The conditional expression terminates when a matching <span class="varname">}</span> is found.
                </p>
                <p>
If a variable is declared within a block, then it is <strong>not</strong> accessible outside of that block:
                </p>
                <pre>
var ok = true
if ok:
    var some_value = 10

# print(some_value) # Syntax Error!</pre>
                <p>
This restriction exists because Lily can't fully guarantee that <span class="varname">some_value</span> will exist and be valid.
                </p>
                <p>
There's also the matter of truthiness. Here's Lily's truthiness table:
                </p>
                <div style="font-family: monospace, mono, \"courier new\"">
                    <div class="row" style="margin-bottom: 10px">
                        <div class="col-sm-4">
                            <strong>
                                Class
                            </strong>
                        </div>
                        <div class="col-sm-4">
                            <strong>
                                False value
                            </strong>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            Boolean
                        </div>
                        <div class="col-sm-4">
                            false
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            ByteString
                        </div>
                        <div class="col-sm-4">
                            B""
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            Integer
                        </div>
                        <div class="col-sm-4">
                            0
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            List
                        </div>
                        <div class="col-sm-4">
                            []
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            String
                        </div>
                        <div class="col-sm-4">
                            ""
                        </div>
                    </div>
                </div>
            </div>
            <div class="section">
                <h1 id="_BlockTypes">
                    Block Types
                </h1>
                <p>
This section will go over the different kinds of blocks that are present in Lily, as well as any important rules they may have.
                </p>
                <p>
<span class="varname">if</span>, <span class="varname">elif</span>, and <span class="varname">else</span>:
                </p>
                <pre>
var my_list = [1, 2, 3]
var length = 0

if my_list == [1]:
    length = 1
elif my_list == [1, 2]:
    length = 2
else:
    length = 3</pre>
                <p>
<span class="varname">while</span>
                </p>
                <pre>
var entries = [1, 2, 3]
var i = 0
while i != entries.size(): {
    var e = entries[i]
    if e == 4:
        break
    elif e == 3:
        continue

    print (e)
}</pre>
                <p>
<span class="varname">do</span> ... <span class="varname">while</span>
                </p>
                <pre>
var entries = [1, 2, 3]
var i = 1
var counter = 3

do: {
    var inner = 2
    var e = entries[i]
    if e == inner:
        break
    elif e == 3:
        continue

    counter -= 1
} while counter</pre>
                <p>
<span class="varname">do while</span> cannot use inner loop variables for the condition.
As such, using <span class="varname">} while inner:</span> is a Syntax error.
Again, Lily cannot verify that the inner loop variable has been initialized.
For example, you may have written:
                </p>
                <pre>
do: {
    continue
    var v = 10
} while v:</pre>
                <p>
<span class="varname">for</span>
                </p>
                <pre>
for i in 0...5:
    print(i)

# print(i) # Syntax error!

var i
for i in 0...5:
    print(i)

print(i) # 5

for i in 0...5 by 2:
    print(i)</pre>
                <p>
There are two other kinds of blocks: <span class="varname">match</span> and <span class="varname">try</span>.
<span class="varname">match</span> will be discussed with DOCLINK enums, and <span class="varname">try</span> will be discussed with Exceptions.
                </p>
            </div>
            <div class="section">
                <h1 id="_Expressions">
                    Expressions
                </h1>
                <p>
A common question of new languages is what operators are available.
Here's Lily's operator table, organized from lowest to highest precedence:
                </p>
                <div style="font-family: monospace, mono, \"courier new\"">
                    <div class="row" style="margin-bottom: 10px">
                        <div class="col-sm-4">
                            <strong>
                                Operator
                            </strong>
                        </div>
                        <div class="col-sm-4">
                            <strong>
                                Description
                            </strong>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            = /= *= += -= &lt;&lt;= &gt;&gt;=
                        </div>
                        <div class="col-sm-4">
                            Assignment / Compound assigment
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            ||
                        </div>
                        <div class="col-sm-4">
                            Boolean OR
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            &amp;&amp;
                        </div>
                        <div class="col-sm-4">
                            Boolean AND
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            == !=
                        </div>
                        <div class="col-sm-4">
                            Equal, not equal
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            &lt; &gt; &lt;= &gt;=
                        </div>
                        <div class="col-sm-4">
                            Comparisons
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            |&gt;
                        </div>
                        <div class="col-sm-4">
                            Function pipe (x |> f is f(x))
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            |
                        </div>
                        <div class="col-sm-4">
                            Bitwise OR
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            ^
                        </div>
                        <div class="col-sm-4">
                            Bitwise XOR
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            &amp;
                        </div>
                        <div class="col-sm-4">
                            Bitwise AND
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            &lt;&lt; &gt;&gt;
                        </div>
                        <div class="col-sm-4">
                            Shifts (Left + Right)
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            + -
                        </div>
                        <div class="col-sm-4">
                            Addition, subtraction
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            * / %
                        </div>
                        <div class="col-sm-4">
                            Multiply, divide, modulo
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-sm-4">
                            + -
                        </div>
                        <div class="col-sm-4">
                            Unary positive, negative
                        </div>
                    </div>
                </div>
                </p>
            </div>
            <div class="section">
                <h1 id="_Classes">
                    Classes
                </h1>
                <p>
Lily's classes are unique, in that their design carries inspiration from a number of different languages.
Here's a really simple one:
                </p>
                <pre>
class Point(x: Integer, y: Integer)
{
    var @x = x
    var @y = y

    define move(moveX: Integer, moveY: Integer)
    {
        @x += moveX
        @y += moveY
    }
}</pre>
                <p>
In Lily, the body of a class (where the assignments are done) is the constructor of the class.
The arguments that come after the name of the class are the parameters to the constructor.
By doing this, Lily can know for sure that all of the members of a class are initialized.
                </p>
                <p>
Within a class, properties are accessed through <span class="varname">@name</span>.
Unfortunately, Lily doesn't support a shorthand constructor syntax.
This is why the <span class="varname">@name = name</span> is currently necessary.
In a future version of Lily, a shorthand syntax for constructors will be possible.
                </p>
                <p>
There's also the <span class="varname">Point.move</span> method.
Currently, all methods of a class implicitly receive <span class="varname">self</span> as their first argument.
                </p>
                <p>
Let's take the above class for a spin:
                </p>
                <pre>
var my_point = Point(0, 0)
my_point.move(10, 0)
my_point.x += 5
my_point.y = 20</pre>
                <p>
In the above example, Lily is able to determine that <code>Point</code> is being used as a constructor.
Since <span class="varname">my_point</span> has the class <code>Point</code>, it is allowed to use <code>Point</code> methods.
An important part of the above example is how the members of the <code>Point</code> class are all accessed through the <span class="varname">.</span> token.
Because Lily uses <span class="varname">.</span> as a universal accessor, Lily also imposes the restriction that a class cannot have a method and a property with the same name:
                </p>
                <pre>
class Point(x: Integer, y: Integer)
{
    var @x = x
    var @y = y
    define y { # Syntax error!
    }
}</pre>
                <p>
The reason for this is that Lily cannot be completely sure in all cases as to which one you might one.
                </p>
                <p>
By default, class members and properties are <strong>public</strong>.
Because <strong>public</strong> is the default, there is no keyword for it, since that would be redundant.
Lily does, however, support the typical <span class="varname">protected</span> and <span class="varname">private</span> modifiers.
                </p>
                <pre>
class Point(x: Integer, y: Integer)
{
    protected var @x = x
    private var @y = y

    private define hidden {
        @x += 10
    }

    define compare(other: Point): Boolean
    {
        return (@x == other.x &amp;&amp;
                @y == other.y)
    }
}

var p = Point(10, 20)
# p.x = 10 # Syntax error: Point.x is protected within Point.
p.hidden() # Syntax error: Point.hidden is hidden within Point.</pre>
                <p>
In Lily, access to <span class="varname">private</span> properties and methods is allowed when within the originating class.
Absent from Lily are getters and setters found in other object-oriented languages.
This has a downside, in that it's currently not possible to have a <span class="varname">var</span> that has, say, a <span class="varname">protected</span> get but a <span class="varname">private</span> set.
                </p>
                <p>
Moving on, Lily also supports inheritance:
                </p>
                <pre>
class Point2D(x: Integer, y: Integer)
{
    var @x = x
    var @y = y

    define move2D(moveX: Integer, moveY: Integer)
    {
        @x += moveX
        @y += moveY
    }
}

class Point3D(x: Integer, y: Integer, z: Integer) &lt; Point2D(x, y)
{
    var @z = z

    define move3D(moveX: Integer, moveY: Integer, moveZ: Integer)
    {
        move2D(moveX, moveY)
        @z += moveZ
    }
}</pre>
                <p>
The <span class="varname">&lt;</span> token is used to indicate inheritance.
Notice how the movement function is written differently between them.
While Lily does support generics, it does not support overloading.
Additionally, it currently does not support a <strong>virtual</strong>-like keyword either.
That may change in a future version of Lily.
                </p>
                <p>
Speaking of inheritance, most of Lily's built-in classes do not support being inherited from.
That too may change in a future version of Lily.
For now, only <code>Exception</code> and <code>Tainted</code> can be inherited from.
                </p>
            </div>
            <div class="section">
                <h1 id="_Exceptions">
                    Exceptions
                </h1>
                <p>
In Lily, all exceptions are implemented as classes within the language.
For a class to be an exception, it must inherit from the built-in class <code>Exception</code>.
<code>Exception</code> is defined within Lily as follows:
                </p>
                <pre>
class Exception(message: String)
{
    var @traceback: List[String] = []
    var @message = message
}</pre>
                <p>
Lily comes with a handful of Exception classes. They are:
                </p>
                <ul>
                    <li>
<code>DivisionByZeroError</code>: Attempting to divide or modulo by 0.
                    </li>
                    <li>
<code>FormatError</code>: Giving a formatting function either too many or too few arguments.
                    </li>
                    <li>
<code>IndexError</code>: Attempting to index a <code>List</code> or <code>String</code> with an invalid index (too big or too small).
                    </li>
                    <li>
<code>IOError</code>: Attempting to read from a write-only stream, or vice versa, or an issue opening a <code>File</code>.
                    </li>
                    <li>
<code>KeyError</code>: Attempting to get an item from a <code>Hash</code> that does not exist.
                    </li>
                    <li>
<code>RuntimeError</code>: Attempting to remove a <code>Hash</code> key during iteration, or comparing an infinite structure.
                    </li>
                    <li>
<code>ValueError</code>: An invalid argument has been sent (ex: <span class="varname">Option.unwrap</span> on <span class="varname">None</span>).
                    </li>
                </ul>
                <p>
It is possible to extend either <code>Exception</code> or one of the above classes to create custom exceptions.
Said custom exceptions can include extended information, such as an error code, or other interesting values.
                </p>
                <p>
The keyword <span class="varname">raise</span> is used to raise an exception.
When an exception is raised, the <span class="varname">Exception.traceback</span> field is updated to contain the current stack information (and old information is erased).
                </p>
                <p>
Handling exceptions is done through <span class="varname">try</span> + <span class="varname">except</span>.
Here's one example:
                </p>
                <pre>
try:
    1 / 0
except DivisionByZeroError as e:
    print($"Traceback: ^(e.traceback)")
except Exception:
    0 # Unreachable</pre>
                <p>
The exception branch that is chosen is not the most specific one, but rather the one that is seen first
                </p>
                <pre>
try:
    raise ValueError("That value is wrong!")
except Exception:
    print("Got it!")
except ValueError:
    1 # Unreachable</pre>
                <p>
While exceptions are available, it is preferable to use <code>Option</code> or <code>Either</code> when possible.
The reason for this is that <code>Option</code> and <code>Either</code> are chainable, whereas exceptions interrupt flow.
Exceptions should be thought of as a last resort, and never as a first one.
                </p>
            </div>
            <div class="section">
                <h1 id="_Lambdas">
                    Lambdas
                </h1>
                <p>
Sometimes you need a function but it's so small that you don't need to give it a name.
This is where lambdas come in.
Lambdas are a way of having a very terse function that relies heavily on inference.
Here's one example:
                </p>
                <pre>
define inplace_sort(input: List[Integer], cmp: Function(Integer, Integer =&gt; Boolean))
    : List[Integer]
{
    for i in 0...input.size() - 1: {
        var j = i
        while j > 0 &amp;&amp; cmp(input[j - 1], input[j]): {
            var temp = input[j]
            input[j] = input[j - 1]
            input[j - 1] = temp
            j -= 1
        }
    }
    return input
}

inplace_sort([1, 3, 5, 2, 4], {|a, b| a &gt; b}) # [1, 2, 3, 4, 5]
inplace_sort([1, 3, 2],       {|a, b| a &lt; b}) # [3, 2, 1]</pre>
                <p>
Most of this shouldn't be surprising by now.
<span class="varname">inplace_sort</span> takes in a <code>List</code> and mutates the elements so that they are sorted.
The sorting order depends on the comparison function, <span class="varname">cmp</span>.
<span class="varname">inplace_sort</span> with a starting <code>List</code>, and the lambda.
The first lambda is: <span class="varname">{|a, b| a &gt; b }</span>.
                </p>
                <p>
Lambdas work off of inference.
This lambda creates two temporary variables for the two inputs that it has.
The return of a lambda is inferred instead of explicit, to allow it to be more terse.
By using a lambda, the intent is clearer than using a function (whose source may have to be searched for).
                </p>
                <p>
Occasionally, there's a method that you'd like to call with a lambda, and that lambda will be the only argument.
Here's one example:
                </p>
                <pre>
[1, 2, 3].each({|e| print(e) })</pre>
                <p>
In this kind of situation, the parentheses don't serve any real value.
If you have a value of some kind, and write a lambda, then Lily will assume that the lambda applies to the value.
Doing so allows the elimination of those parentheses that don't do anything:
                </p>
                <pre>
[1, 2, 3].each{|e| print(e) }</pre>
                <p>
Occasionally, it's useful to specify the type of a lambda's argument:
                </p>
                <pre>
var math_ops = [
    "+" =&gt; {|a: Integer, b: Integer| a + b },
    "-" =&gt; {|a, b| a - b},
    "*" =&gt; {|a, b| a * b},
    "/" =&gt; {|a, b| a / b}]

    math_ops["+"](10, 20) |&gt; print</pre>
                <p>
Lily's type inference is smart enough to take the hints from the first lambda, and apply them to the other lambdas.
Doing it this way avoids writing a huge type for <span class="varname">math_ops</span> itself (<code>Hash</code><span>[</span><code>String</code><span>, </span><code>Function</code><span>(</span><code>Integer</code><span>, </span><code>Integer</code><span> =&gt; </span><span class="varname">Integer</span><span>)]</span>).
                </p>
                <p>
There are some limitations to lambdas, however.
If a lambda spans multiple lines, the value that is returned is the last expression, unless it's a block.
Additionally, lambdas are currently unable to raise an exception.
Explicit returns are also forbidden within a lambda, but that is by design (lambdas should be straightforward).
                </p>
            </div>
            <div class="section">
                <h1 id="_Generics">
                    Generics
                </h1>
                <p>
The design of Lily's generics is largely inspired by Scala.
As such, generic types are indicated between <code>[</code> and <code>]</code>, right after the name of a class or function.
Here's what it looks like, in practice.
                </p>
                <pre>
define fold[A](input: List[A], start: A, combine: Function(A, A =&gt; A)): A
{
    var total = start
    input.each{|e| total = combine(total, e) }
    return total
}

fold([1, 2, 3], 0, {|a, b| a + b }) |&gt; print              # 6
fold(["1", "2", "3"], "", {|a, b| $"^(a)^(b)" }) |&gt; print # "123"</pre>
                <p>
<span class="varname">fold</span> accumulates elements of a <code>List</code> together using <span class="varname">combine</span> as an accumulator.
Lily's generics work by associating types.
Initially, it doesn't know what <code>A</code> should be.
It sees that that, in the first call, <code>A</code> is solved as <code>Integer</code>.
So long as subsequent uses of <code>A</code> solve as <code>Integer</code> or better, then everything is ok.
Additionally, it should be noted that Lily is smart enough to pass down inference information to the lambda.
This means that the lambdas know their types.
                </p>
                <p>
Let's take a look at the <code>Tainted</code> class, for another use of generics.
The <code>Tainted</code> class is defined internally as:
                </p>
                <pre>
class Tainted[A](value: A)
{
    private var @value = value
    define sanitize[B](f: Function(A =&gt; B)): B
    {
        return f(@value)
    }
}</pre>
                <p>
Since <code>Tainted.sanitize</code> is in a scope that already has <code>A</code> defined, it only needs to establish <code>B</code>.
In a future version of Lily, the language may automatically infer that a single capital letter is a generic, and thus not require the definition on <span class="varname">Tainted.sanitize</span>.
Let's see some usage of <code>Tainted</code>.
                </p>
                <pre>
var bad_string = Tainted("&amp;")
# var bad_idea = bad_string.value # Syntax error, because @value is private.

var clean_string = bad_string.sanitize(String.html_encode)
print(clean_string) # &amp;amp;

# What about something more interesting though?

var maybe_int = Tainted("123").sanitize(String.parse_i)
maybe_int.unwrap() |&gt; print # 123

# A <!-- cat --> lambda is fine too:
var ok_string = Tainted(1e1).sanitize{|a| a.to_s() }
print(ok_string) # 100</pre>
                <p>
The last example shows off Lily's inference capabilities.
The lambda is able to infer that <span class="varname">a</span> has the generic type <code>A</code>, and that <code>A</code> is solved as <code>Integer</code>.
But what about the return?
Since <code>B</code> is not established, it's set to whatever the lambda returns.
The design of <code>Tainted</code> is intentional, as it allows both transforming and cleaning the inner value at the same time.
                </p>
                <p>
Lily's generics, while good at inference, are lacking in other areas.
There's currently no support for constraints on generics (Inability to specify that, say <code>A</code> satisfies some interface.
There's also a limitation on generics, in that they must be declared in alphabetical order.
There are other limitations, but these are thought to be the ones that will be noticed the most.
In a future version of Lily, both of those (especially named generics) are likely to be supported.
                </p>
            </div>
            <div class="section">
                <h1 id="_Enums">
                    Enums
                </h1>
                <p>
Lily's enums have been designed to provide safety though types.
As such, they have been largely modelled after Rust's enums.
Here's an example of an enum used to describe common terminal colors:
                </p>
                <pre>
enum TerminalColor {
    Black
    Blue
    Cyan
    Green
    Magenta
    Red
    White
    Yellow
}

var my_color = Black
# my_color = 10 # Syntax error
print(my_color == Blue) # false</pre>
                <p>
The members of an enum are called its variants.
When a variable is assigned to a variant, it will have the type of the enum.
In the above case, <span class="varname">my_color</span> has the type <code>TerminalColor</code>.
Lily does not allow a variable to have a variant class as a type, as it makes inference more challenging.
                </p>
                <p>
The above example creates an enum that pollutes the scope it's in.
Perhaps you'd like to require that <span class="varname">TerminalColor.&lt;name&gt;</span> be used instead.
Scoped enums can be defined as follows:
                </p>
                <pre>
enum Speed {
    .Fast
    .Medium
    .Slow
}

var my_speed = Speed.Fast
print(my_speed == Speed.Slow) # false</pre>
                <p>
While it is possible to use <span class="varname">==</span> to compare enums, it doesn't guarantee that all cases are covered.
This is where <span class="varname">match</span> comes into play.
<span class="varname">match</span> works like this:
                </p>
                <pre>
var colors = [Red, Green, Blue]

for i in 0...colors.size() - 1: {
    var name = ""
    match colors[i]: {
        case Black:   name = "Black"
        case Blue:    name = "Blue"
        case Cyan:    name = "Cyan"
        case Green:   name = "Green"
        case Magenta: name = "Magenta"
        case Red:     name = "Red"
        case White:   name = "White"
        case Yellow:  name = "Yellow"
    }

    print($"Color ^(i) is ^(name).")
}

var another_speed = Speed.Fast
match another_speed: {
    case Fast:   print("You are going fast.")
    case Medium: print("You are going average.")
    case Slow:   print("You are going slow.")
}</pre>
                <p>
One of the key features of <span class="varname">match</span> is that it is exhaustive.
That is, forgetting one of the cases is a syntax error.
By doing this, Lily can be sure that all cases are handled.
                </p>
                <p>
Variants can also have values inside of them:
                </p>
                <pre>
enum Shape
{
    Line(Integer, Integer)
    Rectangle(Double, Double)
    Square(Integer)
}

var num_lines = 0
var shape_list = [Rectangle(10.5, 20.2), Square(5)]

for i in 0...shape_list.size()-1: {
    match shape_list[i]: {
        case Line(start, end):
            print($"Line: ^(start)...^(end)")
            num_lines += 1
        case Rectangle(width, height):
            print($"Rectangle: ^(width)x^(height)")
        case Square(size):
            print($"Square: ^(size)")
    }
}</pre>
                <p>
When <span class="varname">case</span> has a variant that takes arguments, it is required to give names to all arguments.
It is a syntax error to not give enough arguments for the variant, just as it's a syntax error to not check for all variants.
The above example also shows how each <span class="varname">case</span> is allowed to span multiple expressions.
As of right now, Lily requires that all <span class="varname">match</span> expressions have a brace, so that they span multiple expressions.
In a future version of Lily, such a requirement is likely to be removed.
                </p>
                <p>
Enums are also allowed to have methods on them:
                </p>
                <pre>
enum Direction
{
    North
    East
    South
    West

    define pivot_right: Direction
    {
        match self: {
            case North: return East
            case East:  return South
            case South: return West
            case West:  return North
        }
    }

    define pivot_left: Direction
    {
        match self: {
            case North: return West
            case East:  return North
            case South: return East
            case West:  return South
        }
    }
}</pre>
                <p>
Earlier, there was discussion of <code>Option</code> and <code>Either</code>.
Both are enums, and are defined (roughly) as follows:
                </p>
                <pre>
enum Option[A] {
    Some(A)
    None

    define is_some: Boolean
    {
        match self: {
            case Some(s): return true
            case None:    return false 
        }
    }
    define is_none: Boolean
    { ... }

    define unwrap: A
    {
        match self: {
            case Some(s): return s
            case None:    raise ValueError("unwrap called on None.")
        }
    }

    ...
}

enum Either[A, B] {
    Left(A)
    Right(B)

    # Safely grab the error side
    define left: Option[A]
    {
        match self: {
            case Left(l):  return Some(l)
            case Right(r): return None
        }
    }

    # This time, safely grab the success side.
    define left: Option[B]
    {
        match self: {
            case Left(l):  return None
            case Right(r): return Some(r)
        }
    }

    ...
}</pre>
                <p>
<code>Option</code> and <code>Either</code> are both useful, for different reasons.
<code>Option</code> is useful for denoting that a function should return a value, but may fail.
It's good in cases where the reason is not as important as the why.
<code>Either</code> is a richer way of pushing back errors.
It can be used in cases where there is an error message that could, for example, be pushed back to the user.
It can also be used for signaling that a function may have different values.
                </p>
            </div>
            <div class="section">
                <h1 id="_Dynamic">
                    Dynamic
                </h1>
                <p>
Occasionally, it's useful to defer type checking until runtime.
Lily provides the <code>Dynamic</code> class as a means of doing just that.
The <code>Dynamic</code> class provides a constructor, but that does not mean it is inheritable (the constructor allows <span class="varname">Dynamic(value)</span>, for convenience).
Here's <code>Dynamic</code> in action:
                </p>
                <pre>
var box = Dynamic(10)
box = Dynamic("123")

# Nesting is ok too:
var second_box = Dynamic(box)

# .@(&lt;type&gt;) is for casting.
# The result of a cast is Option[Integer]
var maybe_integer = box.@(Integer)

# print(maybe_integer.unwrap()) # raises ValueError!

var maybe_string = box.@(String)
print(maybe_string.unwrap())</pre>
                <p>
Lily currently does not restrict what types go into a Dynamic, because it has no means to do so.
However, Lily does restrict pulling types with generics out (so <code>.@(List[Integer])</code> won't work).
The reason for this is that Lily does not retain full type information (only class information in some cases).
So, such typecasting is not possible in Lily.
                </p>
            </div>
            <div class="section">
                <h1 id="_ImportAndUse">
                    import and use
                </h1>
                <p>
Thus far, all examples have run as though they were in the same file.
Lily provides two different keywords for using code from other files: <span class="varname">import</span> and <span class="varname">use</span>.
                </p>
                <p>
The first keyword, <span class="varname">import</span>, loads a single module.
It's called a module, because it can provide classes, variables, and functions.
Here's an example of a simple module:
                </p>
                <pre>
# file: utils.lly
class CustomError(message: String, code: Integer) &lt; Exception(message)
{
    var @code = code
}

define fib(n: Integer): Integer
{
    if n &lt; 2:
        return n
    else:
        return fib(n - 1) + fib(n - 2)
}

var some_param = 10

print("Loaded utils.lly!")

# (from another file...)
import utils

utils.fib(10)
print(utils.some_param)
try:
    raise utils.CustomError("Test", 123)
except utils.CustomError:
    print("Caught it!")</pre>
                <p>
Access to data within a module always uses the module's name as a prefix.
Additionally, a module is allowed to have code outside of a function.
That code is run exactly once, the first time a module is loaded.
Subsequent loads only make a module available, but do not run the code again.
                </p>
                <p>
<span class="varname">import</span> also supports some syntatic sugar:
                </p>
                <pre>
# somedir/other_utils.lly
import utils

define and_then[A, B, C](f: Function(A => B), g: Function(B => C)): Function(A => C)
{
    return {|x| f(g(x)) }
}

# (from another file...)
import somedir/other_utils

other_utils.and_then(Integer.to_s, String.parse_i)

import somedir/other_utils as u

u.and_then(Integer.to_s, String.parse_i)

u.utils.fib(1)

import x, y, z</pre>
                <p>
The above shows first how Lily allows loading from a directory other than the current one.
<span class="varname">import</span> always works relative from the currently-loaded file.
It's also possible to load a module under a different name (perhaps you wish to rename postgres to database, for example).
It also shows that one can access modules that have been loaded in other modules.
                </p>
                <p>
There are some limitations to import though.                    
As of right now, there is no way to run a <code>from x import *</code> type import, or to be more selective <code>import (x, y, z) from abc</code>.
                </p>
                <p>
But modules and <span class="varname">import</span> are only half of the story. 
Suppose you have a grouping of modules, and you'd like to distribute them together.
Lily terms this collection as a package.
                </p>
                <p>
<span class="varname">use</span> is the keyword use for loading packages.
Whereas <span class="varname">import</span> has many options, <span class="varname">use</span> is more restrictive.
A use command must specify the name of a package.
By default, Lily provides the <code>sys</code> package which holds argv.
The mod_lily runner provides a <code>server</code> package that provides an api for talking to apache.
                </p>
                <p>
Within any given package, the first file loaded is considered special.
For one, only the first file is able to <span class="varname">use</span> packages.
Determining what a package exports is simple: It's whatever that the first file loaded has available to it.
You can thus look at the first file of a package to get a fair idea of what it needs, and what it provides.
                </p>
                <p>
When <span class="varname">use</span> looks for a module, it searches relative from the first file of the current module.
This design allows multiple versions of a package to exist at the same time.
Packages are expected to be located in a <code>packages</code> directory relative to where the first file is.
Like modules, packages can be either plain text (<code>.lly</code>) or a platform library.
Given the directive <code>use json</code>, Lily will look for:
                </p>
                <p>
<code>./packages/json/package.lly</code>
                </p>
                <p>
<code>./packages/liblily_json.(dll/so)</code>
                </p>
                <p>
...with the <code>./</code> including the relative path to the first file, if need be.
                </p>
                <p>
                <p>
Earlier, it was mentioned that Lily has two modes of operation: <code>standalone</code> and <code>template</code>.
Regardless of the starting mode, the item is always loaded in <code>standalone</code> mode.
Lily is smart enough that it won't serve your code-only files (they won't start with <code>&lt;?lily</code>, and it's invalid for code files).
Another advantage of importing in a consistent mode is that you can easily move your files from standalone to a server.
                </p>
            </div>
            <div class="section">
                <h1 id="_WrappingUp">
                    Wrapping up
                </h1>
                <p>
I hope that this tutorial convinced you to give Lily a try.
I've put more examples up top in the example link.
Those are more complete, runnable bits of code to look over.
I've also put in a sandbox with some demos to play around with.
If nothing else, I really do appreciate you taking the time to look over what I've done with Lily.
                </p>
            </div>
        </div>

        <!-- Bootstrap core JavaScript
        ================================================== -->
        <!-- Placed at the end of the document so the pages load faster -->
        <script src="js/jquery.min.js"></script>
        <script src="js/bootstrap.min.js"></script>
        <script src="js/docs.min.js"></script>
        <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
        <script src="js/ie10-viewport-bug-workaround.js"></script>
    </body>
</html>
