import (Interpreter,
        TestCase) "../t/testing"

class TestEnum < TestCase
{
    public define test_base
    {
        var t = Interpreter()

        # base (assign to class property)

        assert_parse_string(t, """
            class Test {
                public var @value: Option[String] = None
            }

            var v = Some(10)
            v = None

            var t = Test()
            t.value = Some("x")
        """)

        # base (Hash of variants)

        assert_parse_string(t, """
            var h: Hash[Integer, Option[Integer]] = [1 => None, 2 => Some(10), 3 => Some(11)]
        """)

        # base (vararg call)

        assert_parse_string(t, """
            define f[A](values: Option[A]...) {  }

            f(None, None, None)
            f(None, Some(10), None)
            f(Some(10), Some(10))
        """)
    }

    public define test_methods
    {
        var t = Interpreter()

        # methods (enum member function called on variant)

        assert_parse_string(t, """
            enum Test[A] {
                One(A),
                Two

                define or_else(other: A) : A {
                    match self: {
                        case One(s):
                            return s
                        case Two:
                            return other
                    }
                }
            }

            if Test.or_else(One(1), 2) != 1: {
               raise Exception("Failed.")
            }
        """)
    }

    public define test_scope
    {
        var t = Interpreter()

        # scope (no collision for scoped + non-scoped enums)

        assert_parse_string(t, """
            enum StrangeSpeed {
                Fast,
                Medium,
                Slow
            }

            scoped enum Speed {
                Fast,
                Medium,
                Slow
            }
        """)

        # scope (use scoped enums)

        assert_parse_string(t, """
            scoped enum ScopeTest[A] {
                One(A),
                Two
            }

            var v = [ScopeTest.One(1), ScopeTest.Two, ScopeTest.One(2)]
            var check: ScopeTest[Integer] = v[0]
        """)

        # scope (matching scoped enum)

        assert_parse_string(t, """
            match check: {
                case ScopeTest.One(s):
                case ScopeTest.Two:
                    raise Exception("Failed.")
            }
        """)

        # scope (match scoped enum variants directly)

        assert_parse_string(t, """\
            match check: {
                case One(s):
                case Two:
                    raise Exception("Failed.")
            }
        """)
    }

    public define test_shorthand
    {
        var t = Interpreter()

        # test shorthand (expression setup)
        assert_parse_string(t, """
            enum FlatSpeed {
                FSlow,
                FMedium,
                FFast
            }

            scoped enum ScSpeed {
                Slow,
                Medium,
                Fast
            }

            define sc_check(:input input: ScSpeed) {}
            define fl_check(:input input: FlatSpeed) {}
            define takemany[A](a: A, m: A...) {}
            define taketwo[A](a: A, b: A) {}
        """)

        # test shorthand (different calls)
        assert_parse_string(t, """
            sc_check(.Slow)
            sc_check(.Fast)

            fl_check(.FSlow)
            fl_check(.FFast)

            taketwo(ScSpeed.Slow, .Medium)
            taketwo(FSlow, .FSlow)
            takemany(ScSpeed.Slow, .Slow, .Medium)
            takemany(FSlow, .FSlow, .FMedium)
        """)

        # test shorthand (assignments)
        assert_parse_string(t, """
            class Example {
                public var @x: ScSpeed = .Fast
            }

            var v: ScSpeed = .Fast

            define f {
                var w: ScSpeed = .Fast
                var box: List[ScSpeed] = [.Medium]

                box[0] = .Fast

                define g {
                    w = .Medium
                }
            }
        """)

        # test shorthand (return)
        assert_parse_string(t, """
            define g: ScSpeed {
                return .Fast
            }

            define h: FlatSpeed {
                return .FFast
            }
        """)

        # test shorthand (builders)
        assert_parse_string(t, """
            {
                var v2: List[ScSpeed] = [.Fast, .Slow]
                var v3: Hash[Integer, ScSpeed] = [1 => .Fast]
                var v4: Tuple[ScSpeed] = <[.Fast]>
            }
            {
                var v2: List[FlatSpeed] = [.FFast, .FSlow]
                var v3: Hash[Integer, FlatSpeed] = [1 => .FFast]
                var v4: Tuple[FlatSpeed] = <[.FFast]>
            }
        """)

        # test shorthand (practical nested usage)
        assert_parse_string(t, """
            scoped enum Tree {
                Leaf(Integer),
                Branch(Tree, Tree)
            }

            define check(t: Tree)
            {
                var v2 = t ++ ""

                if v2 != "Tree.Branch(Tree.Leaf(1), Tree.Leaf(2))": {
                    0 / 0
                }
            }

            check(.Branch(.Leaf(1), Tree.Leaf(2)))
        """)
    }

    public define test_value_variants
    {
        var t = Interpreter()

        # test value variants (basic usage, numeric interpolation)
        assert_parse_string(t, """
            scoped enum Direction < Integer {
                North,
                East = -2,
                South,
                West = 4567890
            }

            var directions = [.North, .East, .South, .West]
                                .@(List[Direction])
                                .map(|m| (m ++ "").parse_i().unwrap() )

            if directions != [0, -2, -1, 4567890]: {
                0 / 0
            }
        """)

        # test value variants (flat enum too)
        assert_parse_string(t, """
            enum FlatDirection < Integer {
                FNorth,
                FEast = -2,
                FSouth,
                FWest = 4567890
            }

            var flat_directions = [.FNorth, .FEast, .FSouth, .FWest]
                                    .@(List[FlatDirection])
                                    .map(|m| (m ++ "").parse_i().unwrap() )

            if flat_directions != [0, -2, -1, 4567890]: {
                0 / 0
            }
        """)

        # test value variants (coerce to Integer)
        assert_parse_string(t, """
            var v: Integer = Direction.South

            directions = [Direction.North, Direction.East, Direction.South,
                          Direction.West]
                          .@(List[Integer])

            if v != -1 ||
               directions != [0, -2, -1, 4567890]: {
                0 / 0
            }
        """)

        # test value variants (variance)
        assert_parse_string(t, """
            enum LR < Integer {
                Left = 0,
                Right = 1
            }

            define x(a: Integer, b: Integer): Integer
            {
                if a != b: { 0/0 }
                return Left
            }

            x(Left, 0)
            x(Right, 1)
        """)

        # test value variants (typecast narrowing)
        assert_parse_string(t, """
            define x2[A](a: A, b: A) { }

            x2(Left.@(Integer), 0)
        """)
    }

    public define test_trailing_comma
    {
        var t = Interpreter()

        assert_parse_string(t, """
            enum Example {
                One,
                Two,
                Three,
            }

            enum ExampleB {
                BOne,
                BTwo,
                define f {}
            }

            enum ValueExample < Integer {
                First = 1,
                Second = 2,
                Third = 3,
            }

            enum ValueExampleB < Integer {
                BFirst = 1,
                BSecond = 2,
                define f {}
            }

            scoped enum ScopedExample {
                SFirst,
                SSecond,
                SThird,
            }

            scoped enum ScopedExampleB {
                SFirst,
                SSecond,
                define f {}
            }
        """)
    }
}
