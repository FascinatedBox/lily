import test

var t = test.t

t.scope(__file__)

t.assert("Cover unary merging.",
         (||
    var v = 10

    v = --v
    v == 10 ))

t.interpret("Cover using a for loop with global var index.",
    """
    var global_index = 0
    var global_l: List[Integer] = []
    var local_l: List[Integer] = []

    define f {
        for global_index in 0...10: {
            global_l.push(global_index)
        }

        for i in 0...10: {
            local_l.push(i)
        }
    }

    f()

    if global_l != local_l: {
        raise Exception("Failed.")
    }
    """)

t.assert("Cover a loop with a break in the same branch.",
         (||
    for i in 0...10: {
        break
    }

    true ))

t.interpret("Cover subscript inference through a dot access.",
    """\
    class Example {
        public var @a = [[1], [2], [3]]
    }

    var v = Example()
    v.a[0] = []
    """)

t.assert("Cover a variant doing method lookup via the parent.",
         (||
    Some(1).is_some() ))

t.interpret("Cover special case closure transform of a generic call.",
    """
    define f(a: Function()) {
        define g {
            var v = a
            a = v
        }

        var i = 1

        if i == 1: {
            a()
        else:
            a()
        }
    }
    """)

t.interpret("Cover compound assign with dot access.",
    """\
    class Example {
        public var @a = 10
    }

    var v = Example()
    v.a += 5

    if v.a != 15: {
        raise Exception("Failed")
    }
    """)

t.assert("Cover compound assign with subscript access.",
         (||
    var v = [5, 10, 15]

    v[1] += 20
    v == [5, 30, 15] ))

t.interpret_for_error("Cover wrong type for static Tuple.",
    """\
    SyntaxError: Cannot assign type 'Tuple[Integer]' to type 'Tuple[String]'.\n    \
        from test\/[subinterp]:1:\
    """,
    """\
    var v: Tuple[String] = <[1]>
    """)

t.interpret_for_error("Cover uncaptured exception with foreign function.",
    """\
    ValueError: unwrap called on None.\n\
    Traceback:\n    \
        from [builtin]: in Option.unwrap\n    \
        from test\/[subinterp]:2: in __main__\
    """,
    """\
    var v: Option[Integer] = None
    v.unwrap()
    """)

t.assert("Cover single-expression while loop.",
         (||
    var v = 1

    while v != 10: {
        v += 1
    }

    v == 10 ))

t.assert("Cover <[ when wanting an operator.",
         (||
    var v = 1
    <[1]> == <[1]> ))

t.assert("Cover for loop with negative step.",
         (||
    var l: List[Integer] = []
    for i in 5...0 by -1: {
        l.push(i)
    }

    l == [5, 4, 3, 2, 1, 0] ))

t.assert("Decimal value with leading zeroes.",
         (||
    var v = 0000000000000000000000000000000000000000000000000001

    v == 1 ))

t.assert("Octal value with leading zeroes.",
         (||
    var v = 0c0000000000000000000000000000000000000000000000000001

    v == 0c1 ))

t.assert("Cover division using Double values.",
         (|| 25.0 / 5.0 == 5.0 ))

t.assert("Cover multiplication using Double values.",
         (|| 5.0 * 5.0 == 25.0 ))

t.assert("Cover subtraction using Double values.",
         (|| 5.0 - 5.0 == 0.0 ))

t.assert("Cover addition using Double values.",
         (|| 5.0 + 5.0 == 10.0 ))

t.interpret("Verify foreign function error recovery on exception.",
    """\
    var h = [1 => 1, 2 => 2, 3 => 3, 4 => 4]

    try: {
        h.select(|key, value| h.delete(key) true )
        raise Exception("Hash.delete did not fail properly during select.")
    except RuntimeError:
        0
    }

    try: {
        h.delete(4)
    except RuntimeError:
        raise Exception("Hash.delete should not fail outside select.")
    }

    try: {
        h.select(|key, value|
            if key == 2: {
                key = key / 0
            }

            true )
        raise Exception("Hash select lambda should have raised an error.")
    except DivisionByZeroError:
        0
    }

    try: {
        h.delete(1)
    except DivisionByZeroError:
        raise Exception("Hash select did not recover properly.")
    }
    """)

t.assert("Subscript get of a ByteString value.",
         (|| B"123"[0] == '1' ))

t.assert("Subscript assign of a ByteString value.",
         (||
    var v = B"123"
    v[0] = '3'
    v == B"323" ))

t.interpret("Verify print failing if stdout is closed.",
    """\
    stdout.close()
    try: {
        print(0)
        raise Exception("Failed.")
    except ValueError:
        0
    }
    """)

t.interpret_for_error("Cover internal KeyError with large Integer value.",
    """\
    KeyError: 9000000000000000000\n\
    Traceback:\n    \
        from test\/[subinterp]:2: in __main__\
    """,
    """\
    var v = [1 => 1]
    var w = v[9000000000000000000]
    """)

t.interpret_for_error("Cover internal KeyError with reasonable Integer value.",
    """\
    KeyError: 65535\n\
    Traceback:\n    \
        from test\/[subinterp]:2: in __main__\
    """,
    """\
    var v = [1 => 1]
    var w = v[65535]
    """)

t.interpret("Cover msgbuf interpolation of a scoped enum.",
    """\
    scoped enum Example {
        Zero,
        One(Integer)
    }

    var zero = Example.Zero
    var one = Example.One(1)

    if "{0}".format(zero) != "Example.Zero": {
        raise Exception("Failed to interpolate an empty scoped variant.")
    }

    if "{0}".format(one) != "Example.One(1)": {
        raise Exception("Failed to interpolate a scoped variant with args.")
    }
    """)

t.interpret("Cover msgbuf interpolation of a flat enum.",
    """\
    enum Example {
        Zero,
        One(Integer)
    }

    var zero = Example.Zero
    var one = Example.One(1)

    if "{0}".format(zero) != "Zero": {
        raise Exception("Failed to interpolate an empty scoped variant.")
    }

    if "{0}".format(one) != "One(1)": {
        raise Exception("Failed to interpolate a scoped variant with args.")
    }
    """)

t.interpret("Cover interpolation of a Unit value.",
    """
    define f {}

    if "{0}".format(f()) != "unit": {
        raise Exception("Failed.")
    }
    """)

t.interpret("Cover interpolation of File.",
    """
    var v = stdout
    var w = stdin
    w.close()

    if "{0}".format(v).starts_with("<open file at ") == false: {
        raise Exception("Failed to interpolate an open file.")
    }

    if "{0}".format(w).starts_with("<closed file at ") == false: {
        raise Exception("Failed to interpolate a closed file.")
    }
    """)

t.assert("Cover interpolation of a Hash.",
         (||
    var h = [1 => 1, 2 => 2, 3 => 3]
    var v = "{0}".format(h)
    true ))

t.assert("Cover interpolation of a List.",
         (||
    var v = "{0}".format([1, 2, 3])

    v == "[1, 2, 3]" ))

t.assert("Cover interpolation of a Tuple.",
         (||
    var v = "{0}".format(<[1, [2], 3.5]>)

    v == "<[1, [2], 3.5]>" ))

t.assert("Cover interpolation of a built-in function.",
         (||
    var v = "{0}".format(print)

    v == "<built-in function print>" ))

t.assert("Cover interpolation of a built-in method.",
         (||
    var v = "{0}".format(String.parse_i)

    v == "<built-in function String.parse_i>" ))

t.interpret("Cover interpolation of a native function.",
    """
    define f { }

    if "{0}".format(f) != "<function f>": {
        raise Exception("Failed.")
    }
    """)

t.interpret("Cover interpolation of a native method.",
    """
    class Example {
        public define f {}
    }

    if "{0}".format(Example.f) != "<function Example.f>": {
        raise Exception("Failed.")
    }
    """)

t.assert("Cover interpolation of a Double.",
         (||
    "{0}".format(5.5) == "5.5" ))

t.assert("Cover interpolation of a printable Byte ('a').",
         (||
    "{0}".format('a') == "'a'" ))

t.assert("Cover interpolation of a printable Byte ('\\n').",
         (||
    "{0}".format('\n') == "'\\n'" ))

t.assert("Cover interpolation of a printable Byte (255).",
         (||
    "{0}".format('\255') == "'\\255'" ))

t.assert("Cover interpolation of true.",
         (||
    "{0}".format(true) == "true" ))

t.assert("Cover interpolation of false.",
         (||
    "{0}".format(false) == "false" ))

t.assert("Cover interpolation of List[String].",
         (||
    "{0}".format(["abc"]) == "[\"abc\"]" ))

t.assert("Cover interpolation of ByteString.",
         (||
    "{0}".format(B"a\128b\n") == "a\\128b\\n" ))

t.assert("Cover comparison of List[Double].",
         (||
    [1.5] == [1.5] ))

t.assert("Cover incorrect nested comparison.",
         (||
    [1.5] != [5.5] ))

t.assert("Cover reserving a big List.",
         (||
    var v = List.repeat(0, 20)
    v.map(Integer.to_d)
    true ))

t.assert("Cover a do-while with a non-literal condition.",
         (||
    var v = 1
    do: {
        v += 1
    } while v == 1

    true ))

t.interpret("Cover subscript inference through a solved prop.",
    """
    class Test[A](a: A) {
        public var @v = [a]
    }

    var v = Test(1)

    v.v[0] = 2

    if v.v[0] != 2: {
        raise Exception("Failed.")
    }
    """)

t.assert("Cover subscript inference through Tuple.",
         (||
    var v = [<[1, [2.0], "3"]>]
    v[0][1] = []

    v == [<[1, [], "3"]>] ))

t.interpret("Cover scanning over Windows newlines.",
    """
    var v = 10\r\n\
    v = 11\r\n\
    if v != 11: {\r\n\
        raise Exception("Failed.")
    }
    """)

t.interpret_for_error("Cover wrong type with a vararg function.",
    """\
    SyntaxError: Cannot assign type 'Function (Integer...)' to type 'Integer'.\n    \
        from test\/[subinterp]:2:\
    """,
    """\
    define f(a: Integer...) {}
    var v: Integer = f
    """)

t.interpret_for_error("End tag in code-only file.",
    """\
    SyntaxError: Unexpected token '?>'.\n    \
        from test\/[subinterp]:1:\
    """,
    """\
    ?>
    """)

t.expression("Basic expression coverage.",
    """\
    (Integer): 10\
    """,
    """\
    10
    """)

t.expression("String expression has quotes.",
    """\
    (String): "asdf"\
    """,
    """\
    "asdf"
    """)

t.expression("Broken expression.",
    """\
    SyntaxError: Unexpected token 'end of file'.\n    \
        from test\/[subinterp]:2:\
    """,
    """\
    1 +
    """)

t.interpret("Cover declaring a var of type Unit.",
    """
    define f { }

    var v: Unit = f()
    """)

t.interpret("Cover equality of an empty function return and 'unit'.",
    """
    define f { }

    if f() != unit: {
        raise Exception("Failed.")
    }
    """)

t.interpret_for_error("Cover printing a Function with optional varargs.",
    """\
    SyntaxError: Cannot assign type 'Function (*Integer...)' to type 'Integer'.\n    \
        from test\/[subinterp]:3:\
    """,
    """\
    define f(a: *Integer... = []) { }

    var v: Integer = f
    """)

t.interpret_for_error("Cover else after else in multi-line if.",
    """\
    SyntaxError: else after else in multi-line if block.\n    \
        from test\/[subinterp]:5:\
    """,
    """\
    if 1: {
        1
    else:
        1
    else:
        1
    }
    """)

t.interpret_for_error("Cover elif after else in multi-line if.",
    """\
    SyntaxError: elif after else in multi-line if block.\n    \
        from test\/[subinterp]:5:\
    """,
    """\
    if 1: {
        1
    else:
        1
    elif 1:
        1
    }
    """)

t.interpret("Cover comparison of Byte values.",
    """\
    if 10t > 11t: {
        raise Exception("Failed (>).")
    }

    if 10t >= 10t: {
        0
    else:
        raise Exception("Failed (>=).")
    }

    if 11t <= 11t: {
        0
    else:
        raise Exception("Failed (<=).")
    }

    if 12t <= 11t: {
        raise Exception("Failed (<=).")
    }
    """)

# This test leaks memory if circular values aren't dropped properly.
t.interpret("Cover leaving a circular value at exit.",
    """
    class Example {
        public var @a: Option[Example] = None
    }

    var v = Example()
    v.a = Some(v)
    """)

t.interpret_for_error("Ensure List.zip does not leak scoop.",
    """\
    SyntaxError: Cannot assign type 'Integer' to type 'List[Tuple[Integer, Unit]]'.\n    \
        from test\/[subinterp]:3:\
    """,
    """\
    var v = [1, 2].zip([])

    v = 1
    """)

t.assert("Compare two Lists with equal initial parts, different size.",
         (||
    [1, 2, 3] != [1, 2, 3, 4] ))

t.assert("Compare two Hash values of different size.",
         (||
    ["a" => 1] != ["a" => 1, "b" => 2] ))

t.assert("Compare two Hash values with equal keys but different values.",
         (||
    ["a" => 1, "b" => 2] != ["a" => 2, "b" => 4] ))

t.assert("Compare two Hash values with mismatched keys.",
         (||
    ["a" => 1, "b" => 2] != ["c" => 2, "d" => 4] ))

t.interpret("Compare two infinitely nested values.",
    """
    enum Tree {
        Leaf(Integer),
        Branch(List[Tree])
    }

    var b0 = [Leaf(0)]
    var t0 = Branch(b0)

    b0[0] = t0

    var b1 = [Leaf(1)]
    var t1 = Branch(b1)

    b1[0] = t1

    try: {
        b1 == b0
    except RuntimeError:
        b0[0] = Leaf(1)
        b1[0] = Leaf(1)
    }
    """)

t.interpret("Compare different non-empty variants of same enum.",
    """
    enum Example {
        One(Integer),
        Two(Integer)
    }

    var a = One(1)
    var b = Two(1)

    if a == b: {
        raise Exception("Failed")
    }
    """)

t.interpret("Cover dropping a Coroutine that receives a derefable value.",
    """
    define f(co: Coroutine[Integer, List[Function(Integer)]]): Integer {
        co.yield(1)
        return 1
    }

    var co = Coroutine.build(f)
    co.resume_with([(|x| 10)])
    """)

t.interpret("Cover dropping Function values through gc.",
    """
    define no_op {}

    define closure_base: Function() {
        var inner_fn = no_op
        define a {
            inner_fn = a
        }
        return a
    }

    define f {
        var lst: List[Function()] = []

        for i in 0...5: {
            var local_fn = closure_base()
            local_fn()
            lst.push(local_fn)
        }

        for i in 0...lst.size() - 1: {
            lst[i] = no_op
        }
    }

    f()
    f()
    """)

t.interpret("Cover dropping a Coroutine by deref, not gc.",
    """
    define base_one(co: Coroutine[Integer, Integer]): Integer { return 0 }

    var other_co = Coroutine.build(base_one)

    define co_base(co: Coroutine[Integer, Integer]): Integer {
        co = other_co
        return 10
    }

    # Coroutines start with two refs:
    # The first is from the source vm stack
    # The second is from their own stack (to use for yielding back)
    # This test drops the Coroutine through deref, since they're almost
    # always destroyed by the gc instead.

    define f {
        var local_co = Coroutine.build(co_base)
        local_co.resume_with(0)
    }
    f()
    f()
    """)

t.interpret("Default args of Coroutine and Unit.",
    """
    define base(co: Coroutine[Integer, Integer]): Integer { return 0 }
    var co = Coroutine.build(base)

    define f(a: *Coroutine[Integer, Integer]=co, b: *Unit=unit) {}

    f()
    f(co)
    f(co, unit)
    """)

t.interpret("Build and use a large hash.",
    """
    var letters = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]
    var h: Hash[String, Integer] = []

    var a = 0
    var b = 0
    var c = 0

    for a in 0...letters.size() - 1: {
        for b in 0...letters.size() - 1: {
            for c in 0...letters.size() - 1: {
                var new_key = letters[a] ++ letters[b] ++ letters[c]
                h[new_key] = 0
            }
        }
    }

    h.delete("asdf")
    """)

t.interpret("Hash with colliding member deleted.",
    """
    var keys = ["moderately able aardvark", "moderately abandoned aardvark"]
    var h: Hash[String, Integer] = []

    keys.each(|key| h[key] = 0 )
    h.delete("moderately able aardvark")

    if h.size() != 1: {
        raise Exception("Failed.")
    }
    """)

t.interpret("Cover siphash with long Hash keys.",
    """
    var h: Hash[String, Integer] = []
    var i = 0
    var key = "a"

    for i in 0...32: {
        h[key] = 0
        key = key ++ "a"
    }

    key = ""

    for i in 0...32: {
        h[key] = 1
        key = key ++ "a"
    }
    """)

t.interpret("Cover less-used compound ops.",
    """
    var v = 1000
    var w = 1000
    v /= 10

    if v != (w / 10): {
        raise Exception("Failed.")
    }

    v = 10
    w = 10
    v %= 7

    if v != (w % 7): {
        raise Exception("Failed.")
    }
    """)

t.interpret("Cover truthy do-while.",
    """
    var i = 0
    var l: List[Integer] = []
    do: {
        i += 1
        l.push(i)
        if i == 5: {
            break
        }
    } while 1

    if l != [1, 2, 3, 4, 5]: {
        raise Exception("Failed.")
    }
    """)

t.interpret("Cover truthy do-while.",
    """
    var i = 0
    var l: List[Integer] = []
    do: {
        i += 1
        l.push(i)
        if i == 5: {
            break
        }
    } while 1

    if l != [1, 2, 3, 4, 5]: {
        raise Exception("Failed.")
    }
    """)

t.assert("Cover less-used escapes.",
         (||
    var v = "\'\b"
    var b = B"\999"
    true ))

t.interpret("Docstring for class.",
    """
    ### Documentation for
    ### example
    ### class
    class Example {

    }
    """)

t.interpret("Docstring for public define.",
    """
    class Example {
        ### Docstring for
        ### public definition
        public define a {

        }
    }
    """)

t.interpret("Cover gc tagging bits.",
    """
    class One {
        public var @x = (|| 10 )
    }
    class Two < One {

    }

    class Three {
        public var @a: Option[Three] = None
    }

    class Four < Three {

    }
    """)
