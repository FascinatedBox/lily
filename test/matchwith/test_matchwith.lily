import (Interpreter,
        TestCase) "../t/testing"

# match and with are tested together since they share internal logic

class TestMatchWith < TestCase
{
    public define test_match
    {
        var t = Interpreter()

        # Simple Option case

        assert_parse_string(t, """
            var v = Some(1)
            var w: Option[Integer] = None

            define f(a: Option[Integer]): Boolean {
                match a: {
                    case Some(s):
                        return true
                    case None:
                        return false
                }
            }

            if f(v) != true || f(w) != false: {
                raise Exception("Failed.")
            }
        """)

        # Match with an else

        t = Interpreter()
        assert_parse_string(t, """
            enum RGB {
                Red,
                Green,
                Blue
            }

            var red_count = 0
            var else_count = 0
            var colors = [Red, Blue, Green]

            for i in 0...colors.size()-1: {
                match colors[i]: {
                    case Red: red_count += 1
                    else: else_count += 1
                }
            }

            if red_count != 1 || else_count != 2: {
               raise Exception("Failed.")
            }
        """)

        # Multiple decompositions

        t = Interpreter()
        assert_parse_string(t, """
            enum Abc[A] {
                Def(A, A, A),
                Ghi(A)
            }

            define f(a: Abc[Integer]): Integer {
                match a: {
                    case Def(b, c, d):
                        return b + c + d
                    case Ghi(e):
                        return e
                }
            }

            var v = Def(100, 200, 300)
            var w = Ghi(400)

            if f(v) != 600 || f(w) != 400: {
                raise Exception("Failed.")
            }
        """)

        # Skip decomposition on _

        t = Interpreter()
        assert_parse_string(t, """
            var v = Some(1)
            match v: {
                case Some(_):
                case None:
            }
        """)

        # Match against self in a method

        t = Interpreter()
        assert_parse_string(t, """
            enum Test {
                Left,
                Right
                define is_left: Boolean {
                    match self: {
                        case Left:
                            return true
                        case Right:
                            return false
                    }
                }
            }

            var v = Left
            var w = Right

            if v.is_left() == false || w.is_left() == true: {
                raise Exception("Failed.")
            }
        """)

        # Multi match with commas

        t = Interpreter()
        assert_parse_string(t, """
            enum Example {
                One,
                Two,
                Three(Integer),
                Four,
                Five
            }

            define f(v: Example): Integer
            {
                match v: {
                    case One, Four, Five:
                        return 1
                    case Three(s):
                        return s
                    case Two:
                        return 2
                }
            }

            var v = [
                Five      |> f,
                One       |> f,
                Four      |> f,
                Three(10) |> f,
                Two       |> f,
            ]

            if v != [1, 1, 1, 10, 2]: {
                0 / 0
            }
        """)
    }

    public define test_with
    {
        var t = Interpreter()

        # with using a predefined Option

        assert_parse_string(t, """
            define f(v: Option[Integer]): Integer
            {
                with v as Some(s): {
                    return s
                }

                with v as None: {
                    return 0
                }

                return 0 / 0
            }

            if f(Some(10)) != 10 ||
               f(None) != 0: {
                0 / 0
            }
        """)

        # with over user-defined enums

        assert_parse_string(t, """
            enum Example {
                One(Integer, Integer),
                Two(String),
                Three(List[Integer])
            }

            define f2(v: Example): Integer
            {
                with v as One(a, b): {
                    return a + b
                }
                with v as Two(a): {
                    return a.size()
                }
                with v as Three(a): {
                    return a.push(1).size()
                }

                return 0 / 0
            }

            if f2(One(2, 4)) != 6 ||
               f2(Two("asdf")) != 4 ||
               f2(Three([1])) != 2: {
                0 / 0
            }
        """)

        # with against a class

        assert_parse_string(t, """
            class Four {}
            class Five < Four{}
            class Six < Four{}

            define f3(a: Four): Integer
            {
                with a as Five(t): {
                    return 5
                }
                with a as Six(t): {
                    return 6
                }

                return 4
            }

            if f3(Four()) != 4 ||
               f3(Five()) != 5 ||
               f3(Six()) != 6: {
                0 / 0
            }
        """)

        # with using else

        assert_parse_string(t, """
            var v = Some(1)
            var ok = false

            with v as None: {
                0 / 0
            else:
                ok = true
            }

            if ok == false: {
                0 / 0
            }
        """)
    }

    public define test_with_inside_of_match
    {
        var t = Interpreter()

        # with inside match doesn't corrupt match state

        assert_parse_string(t, """
            var v = Some(1)

            match v: {
                case Some(s):
                    with v as None: {
                        0/0
                    }
                case None:
                    0/0
            }
        """)
    }

    public define test_match_value_variants
    {
        var t = Interpreter()

        # value variants using match

        assert_parse_string(t, """
            scoped enum Direction < Integer {
                North,
                East = -2,
                South,
                West = 4567890
            }

            define match_direction(d: Direction): Integer
            {
                match d: {
                    case East:
                        return 0
                    case South, West:
                        return (d == .West).to_i() + 1
                    else:
                        return 3
                }
            }

            var strictd: List[Direction] = [.North, .East, .South, .West]
            var int_d = strictd.map(match_direction)

            if int_d != [3, 0, 1, 2]: {
                0 / 0
            }
        """)

        # value variants using with

        assert_parse_string(t, """
            define is_south(d: Direction): Boolean
            {
                with d as South: {
                    return true
                else:
                    return false
                }
            }

            var base: List[Direction] = [.North, .East, .South, .West]
            var mapped = base.map(is_south)

            if mapped != [false, false, true, false]: {
                0 / 0
            }
        """)
    }

    public define test_expression_match
    {
        var t = Interpreter()

        # Some of these have already been done with statement match, but do them
        # anyway to prevent accidental divergence.

        assert_parse_string(t, """
            define basic(a: Option[Integer], alt: Integer): Integer
            {
                var result = match a: {
                    case Some(s):
                        s
                    case None:
                        alt
                }

                return result
            }

            if basic(Some(1), 2) != 1 ||
                basic(None, 3) != 3: {
                0/0
            }
        """)

        assert_parse_string(t, """
            define empty_first(a: Option[Integer], alt: Integer): Integer
            {
                var result = match a: {
                    case Some(s):
                        s
                    case None:
                        alt
                }

                return result
            }

            if empty_first(Some(1), 2) != 1 ||
                empty_first(None, 3) != 3: {
                0/0
            }
        """)

        assert_parse_string(t, """
            var g_some = Some(1)
            var g_none = None.@(Option[Integer])

            define using_global_vars: Integer
            {
                var result = match g_some: {
                    case Some(s):
                        1
                    case None:
                        0
                }

                return result
            }

            if using_global_vars() != 1: {
                0/0
            }
        """)

        # Match return from a definition

        assert_parse_string(t, """
            define match_input(a: Option[Integer]): Integer
            {
                return match a: {
                    case Some(s):
                        1
                    case None:
                        0
                }
            }

            if match_input(Some(1)) != 1 ||
               match_input(None) != 0: {
                0/0
            }
        """)

        # Try it from a lambda

        assert_parse_string(t, """
            define send_lambda: Function(Option[Integer] => Integer)
            {
                return (|x|
                    var result = match x: {
                        case Some(s):
                            s
                        case None:
                            0
                    }

                    result
                )
            }

            if send_lambda()(Some(10)) != 10 ||
               send_lambda()(None) != 0: {
                0/0
            }
        """)

        # Unpack multiple values

        assert_parse_string(t, """
            enum MultiValEnum {
                MVOne(Integer, String),
                MVTwo(String, Integer),
            }

            define multival(target: MultiValEnum): Tuple[Integer, String] {
                return match target: {
                    case MVOne(i, s):
                        <[i, s]>
                    case MVTwo(s, i):
                        <[i, s]>
                }
            }

            if multival(MVOne(100, "200")) != <[100, "200"]> ||
                multival(MVTwo("300", 400)) != <[400, "300"]>: {
                0/0
            }
        """)


        # Multiple matches

        assert_parse_string(t, """
            define two_matches(first: Option[Integer], other_i: Integer,
                               second: Option[String], other_s: String)
                               : Tuple[Integer, String]
            {
                var a = match first: {
                    case Some(s):
                        s
                    case None:
                        other_i
                }

                var b = match second: {
                    case Some(s):
                        s
                    case None:
                        other_s
                }

                return <[a, b]>
            }

            var data = [
                <[Some(1), 2, Some("a"), "b", <[1, "a"]> ]>,
                <[Some(1), 2, None, "b",      <[1, "b"]> ]>,
                <[None,    2, Some("a"), "b", <[2, "a"]> ]>,
                <[None,    2, None, "b",      <[2, "b"]> ]>,
            ]

            for d in data: {
                var tm = two_matches(d[0], d[1], d[2], d[3])

                if tm != d[4]: {
                    0/0
                }
            }
        """)

        # Check later cases unify result type and scoped enum matching

        assert_parse_string(t, """
            class Base {}
            class Two < Base {}
            class Three < Base {}

            scoped enum Selection {
                First,
                Second,
                Third,
            }

            var v = match Selection.First: {
                case First:
                    Base()
                case Second:
                    Two()
                case Third:
                    Three()
            }
        """)

        # Yielding variant shorthand through return type inference

        assert_parse_string(t, """
            define return_selection(a: Option[Integer]): Selection {
                return match a: {
                    case Some(s):
                        .First
                    case None:
                        .Second
                }
            }

            if return_selection(Some(1)) != .First ||
                return_selection(None) != .Second: {
                0/0
            }
        """)

        # Use enum self as a source

        assert_parse_string(t, """
            scoped enum SelfCheck {
                First,
                Second,

                define is_first: Boolean {
                    return match self: {
                        case First:
                            true
                        case Second:
                            false
                    }
                }
            }

            if SelfCheck.First.is_first() == false ||
               SelfCheck.Second.is_first() == true: {
                0/0
            }
        """)

        # Assign to a class member

        assert_parse_string(t, """
            class ClassCheck(a: Option[Integer]) {
                public var @x = a
                public var @y = match @x: {
                    case Some(s):
                        s
                    case None:
                        0
                }
            }

            var c = ClassCheck(Some(1))

            if c.x != Some(1) || c.y != 1: {
                0/0
            }

            c = ClassCheck(None)

            if c.x != None || c.y != 0: {
                0/0
            }
        """)
    }

    public define test_expression_skipping
    {
        var t = Interpreter()

        # Skip the middle

        assert_parse_string(t, """
            enum Multi {
                One(Integer, String, Integer),
                Two
            }

            {
                var v = match One(1, "2", 3): {
                    case One(a, _, c):
                        a + c
                    case Two:
                        0/0
                }

                if v != 4: {
                    0/0
                }
            }
        """)

        # Skip the ends

        assert_parse_string(t, """
            {
                var v = match One(1, "2", 3): {
                    case One(_, b, _):
                        b ++ b
                    case Two:
                        (0/0).to_s()
                }

                if v != "22": {
                    0/0
                }
            }
        """)
    }

    public define test_expression_match_else
    {
        var t = Interpreter()

        assert_parse_string(t, """
            {
                var v = match Some(1): {
                    case Some(s):
                        1
                    else:
                        0
                }

                if v != 1: {
                    0/0
                }
            }
        """)

        assert_parse_string(t, """
            {
                var v = match None.@(Option[Integer]): {
                    case Some(s):
                        1
                    else:
                        0
                }

                if v != 0: {
                    0/0
                }
            }
        """)

        assert_parse_string(t, """
            enum RGB {
                Red,
                Green,
                Blue,

                define is_green: Boolean
                {
                    return match self: {
                        case Green:
                            true
                        else:
                            false
                    }
                }
            }

            if Green.is_green() == false ||
                Red.is_green() == true ||
                Blue.is_green() == true: {
                0/0
            }
        """)
    }
}
