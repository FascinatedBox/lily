import (Interpreter,
        TestCase) "../t/testing", fs

class TestPkgFs < TestCase
{
    public define test_most
    {
        # These methods are tested together to make sure the filesystem is put
        # back the way it started. Also, less actions are made this way.
        # Directory reading isn't included since it doesn't mutate.

        var long_name = List.repeat(15, "qwertyuiop").join("")
        var original_dir = fs.current_dir()

        # Start with the basics.
        assert_not_equal(fs.current_dir(), "")

        var long_dir = original_dir ++ "\/" ++ long_name
        var t = Interpreter()

        # Create a long directory to check fs.current_dir too.
        fs.create_dir(long_name, 0c777)

        # Switch to a long directory.
        fs.change_dir(long_dir)
        assert_equal(fs.current_dir(), long_dir)

        # Get the current directory through a subinterpreter.
        # A subinterpreter is used to make sure fs.current_dir handles growing
        # the vm's buffer for long paths correctly.
        assert_parse_string(t, """
            import fs

            if fs.current_dir() != "%1": {
                0 / 0
            }
        """.replace("%1", long_dir)
           .replace("\\", "\\\\"))

        # Switch back out of it.
        fs.change_dir(original_dir)
        assert_equal(fs.current_dir(), original_dir)

        # Delete it.
        try: {
            fs.remove_dir(long_dir)
        except IOError:
            assert_true(false)
        }

        var message = ""

        # Make sure it's gone.
        try: {
            fs.change_dir(long_dir)
        except IOError as e:
            message = e.message
        }

        message.starts_with("Errno ") |> assert_true

        var dir_tail = original_dir.split("\/")[-1]
        var same_dir = original_dir ++ "\/..\/" ++ dir_tail

        # Try to create the current directory.
        try: {
            fs.create_dir(same_dir)
        except IOError as e:
            message = e.message
        }

        message.starts_with("Errno ") |> assert_true
    }

    public define test_read_dir
    {
        # Current directory should be the project directory.
        var file_paths: List[String] = []
        var dir_paths: List[String] = []
        var first = fs.read_dir(".")
        var w = [dir_paths, file_paths]

        match first: {
            case Success(su):
                w = su.each_entry([dir_paths, file_paths], (|e, temp|
                    match e: {
                        case Directory(path):
                            temp[0].push(path)
                        case File(path):
                            temp[1].push(path)
                    }
                ))

                if w != [dir_paths, file_paths]: {
                    0/0
                }

                if file_paths == [] || dir_paths == []: {
                    0/0
                }

                if dir_paths.select(|s| s == "." || s == ".." ).size(): {
                    0/0
                }

                if dir_paths.select(|s| s == "src").size() == 0: {
                    0/0
                }

                if file_paths.select(|s| s == "README.md").size() == 0: {
                    0/0
                }
            case Failure(message):
                raise IOError(message)
        }

        # A Dir can't be iterated over twice.

        match first: {
            case Success(su):
                var check_w = su.each_entry(0xdeadbeef, (|e, _| 0 / 0 ))

                if check_w != 0xdeadbeef: {
                    0/0
                }
            case Failure(message):
                raise IOError(message)
        }

        try: {
            match fs.read_dir("qwertyasdf"): {
                case Success(_):
                    0/0
                case Failure(message):
                    raise IOError(message)
            }
        except IOError:
            # Assume the message is correct if it got this far.
        }

        # The rest use match and a consistent order to prevent testing oopses.

        match fs.read_dir(".\/"): {
            case Success(_):
                # A trailing slash is ok.
            case Failure(_):
                0/0
        }

        match fs.read_dir(file_paths[0]): {
            case Success(_):
                0/0
            case Failure(_):
                # Using a known file fails.
        }

        match fs.read_dir(".\/*"): {
            case Success(_):
                0/0
            case Failure(_):
                # Can't have a * at the end of the path.
        }
    }
}
