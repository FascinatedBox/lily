import (Interpreter,
        StringTarget,
        PackageTarget,
        TestCase) "../t/testing", introspect

class TestPkgIntrospect < TestCase
{
    private var @t_class_payload =
        StringTarget(
            :path "_class",
            :data """\
                ### Test docblock
                class Base
                {
                    ### Public method
                    public define pub(a: Integer): String { return "" }

                    ### Public property
                    public var @pub_prop = 1

                    ### Protected property
                    protected var @pro_prop = ""

                    ### Private property
                    private var @pri_prop = 1.0
                }

                class GenericClass[A, B](public var @test: String) < Base
                {
                    public define f[C](c: C) {}
                }
            """
        )

    private var @t_constant_payload =
        StringTarget(
            :path "_constant",
            :data """\
                ### Test docblock
                constant ct = 10

                constant asdf = "abc"
            """
        )

    private var @t_define_payload =
        StringTarget(
            :path "_define",
            :data """\
                ### f docblock
                define f {}

                define g(a: Integer): String { return "" }

                define h(b: Double...) {}

                define i(c: *String="") {}
            """
        )

    private var @t_enum_payload =
        StringTarget(
            :path "_enum",
            :data """\
                ### FlatEnum docblock
                enum FlatEnum
                {
                    FlatOne,
                    FlatTwo(Integer),
                    FlatThree(String...),
                    FlatFour(:a Integer, :b String)

                    ### f docblock
                    define f(:key a: Integer): Integer { return 1 }

                    define g {}

                    ### h docblock
                    define h {}
                }

                scoped enum ScopedEnum[A, B]
                {
                    ScopedOne(A),
                    ScopedTwo(B),
                    ScopedThree

                    define f {}
                }
            """
        )

    private var @t_fake =
        PackageTarget(
            :path "fake",
            :data """
                var v = 10
            """
        )

    private var @t_nest_example =
        StringTarget(
            :path "nest\/example",
            :data """
                var v = 10
            """
        )

    private var @t_var_payload =
        StringTarget(
            :path "_var",
            :data """\
                ### Var docblock
                var one: Integer = 1

                var two: String = "2"
            """
        )

    public define test_class
    {
        var t = Interpreter.with_targets(
            @t_class_payload
        )

        t.config_set_extra_info(true)

        assert_parse_string(t, """
            import introspect
            import (Time) time
            import time
            import (Base) _class
            import _class

            define stringify_parameters(p: List[introspect.ParameterEntry])
                : String
            {
                return p.map(|m| "({0},{1},{2})".format(
                    m.name,
                    m.type.as_string(),
                    m.keyword
                )).join()
            }

            define check_method(
                           m:         introspect.MethodEntry,
                :doc       doc:       String,
                :name      name:      String,
                :generics  generics:  String,
                :is_static is_static: Boolean,
                :params    params:    String,
                :private   pri:       Boolean,
                :protected pro:       Boolean,
                :public    pub:       Boolean,
                :result    result:    String,
                :type      type:      String
            )
            {
                var input = <[
                    m.doc(),
                    m.function_name(),
                    m.generics().map(|m_| m_.as_string() ).join(", "),
                    m.is_static(),
                    stringify_parameters(m.parameters()),
                    m.is_private(),
                    m.is_protected(),
                    m.is_public(),
                    m.result_type().as_string(),
                    m.type().as_string()
                ]>
                var expect = <[
                    doc,
                    name,
                    generics,
                    is_static,
                    params,
                    pri,
                    pro,
                    pub,
                    result,
                    type
                ]>

                if input != expect: {
                    raise Exception("\\n    Expected: {0}\\n    Given: {1}"
                            .format(expect, input))
                }
            }

            define check_property(
                           p:    introspect.PropertyEntry,
                :doc       doc:  String,
                :name      name: String,
                :private   pri:  Boolean,
                :protected pro:  Boolean,
                :public    pub:  Boolean,
                :type      type: String
            )
            {
                var input = <[
                    p.doc(),
                    p.name(),
                    p.is_private(),
                    p.is_protected(),
                    p.is_public(),
                    p.type().as_string()
                ]>
                var expect = <[
                    doc,
                    name,
                    pri,
                    pro,
                    pub,
                    type
                ]>

                if input != expect: {
                    raise Exception("\\n    Expected: {0}\\n    Given: {1}"
                            .format(expect, input))
                }
            }

            define check_class(
                          c:        introspect.ClassEntry,
                :doc      doc:      String,
                :foreign  foreign:  Boolean,
                :generics generics: String,
                :name     name:     String,
                :native   native:   Boolean,
                :parent   parent:   String,
                :props    props:    Integer
            )
            {
                var input = <[
                    c.doc(),
                    c.is_foreign(),
                    c.generics().map(|m| m.as_string() ).join(", "),
                    c.name(),
                    c.is_native(),
                    c.parent().map(|a| a.name() ).unwrap_or(""),
                    c.property_count()
                ]>
                var expect = <[
                    doc,
                    foreign,
                    generics,
                    name,
                    native,
                    parent,
                    props
                ]>

                if input != expect: {
                    raise Exception("\\n    Expected: {0}\\n    Given: {1}"
                            .format(expect, input))
                }
            }

            var mm = introspect.main_module()
            var class_m = mm.modules_used()[0]
            var classes = class_m.classes()

            {
                var c = classes[-1]
                var methods = c.methods()
                var properties = c.properties()

                check_class(
                    c,
                    :doc      "Test docblock\\n",
                    :foreign  false,
                    :generics "",
                    :name     "Base",
                    :native   true,
                    :parent   "",
                    :props    3
                )

                check_method(
                    methods[-1],
                    :doc       "Test docblock\\n",
                    :generics  "",
                    :is_static false,
                    :name      "<new>",
                    :params    "",
                    :private   false,
                    :protected false,
                    :public    true,
                    :result    "Base",
                    :type      "Function ( => Base)"
                )

                check_method(
                    methods[-2],
                    :doc       "Public method\\n",
                    :generics  "",
                    :is_static false,
                    :name      "pub",
                    :params    "(,Base,)(a,Integer,)",
                    :private   false,
                    :protected false,
                    :public    true,
                    :result    "String",
                    :type      "Function (Base, Integer => String)"
                )

                check_property(
                    properties[-1],
                    :doc       "Public property\\n",
                    :name      "pub_prop",
                    :public    true,
                    :protected false,
                    :private   false,
                    :type      "Integer"
                )

                check_property(
                    properties[-2],
                    :doc       "Protected property\\n",
                    :name      "pro_prop",
                    :public    false,
                    :protected true,
                    :private   false,
                    :type      "String"
                )

                check_property(
                    properties[-3],
                    :doc        "Private property\\n",
                    :name       "pri_prop",
                    :public     false,
                    :protected  false,
                    :private    true,
                    :type       "Double"
                )

                if methods.size() != 2 ||
                   properties.size() != 3: {
                    0 / 0
                }
            }
            {
                var c = classes[-2]
                var methods = c.methods()
                var properties = c.properties()

                check_class(
                    c,
                    :doc      "",
                    :foreign  false,
                    :generics "A, B",
                    :name     "GenericClass",
                    :native   true,
                    :parent   "Base",
                    :props    4
                )

                check_method(
                    methods[-1],
                    :doc       "",
                    :generics  "A, B",
                    :is_static false,
                    :name      "<new>",
                    :params    "(,String,)",
                    :private   false,
                    :protected false,
                    :public    true,
                    :result    "GenericClass[A, B]",
                    :type      "Function (String => GenericClass[A, B])"
                )

                check_method(
                    methods[-2],
                    :doc       "",
                    :generics  "A, B, C",
                    :is_static false,
                    :name      "f",
                    :params    "(,GenericClass[A, B],)(c,C,)",
                    :private   false,
                    :protected false,
                    :public    true,
                    :result    "Unit",
                    :type      "Function (GenericClass[A, B], C)"
                )

                check_property(
                    properties[-1],
                    :doc        "",
                    :name       "test",
                    :public     true,
                    :protected  false,
                    :private    false,
                    :type       "String"
                )

                if methods.size() != 2 ||
                   properties.size() != 1: {
                    0 / 0
                }
            }

            class_m = mm.modules_used()[1]

            {
                var c = class_m.classes()[0]

                check_class(
                    c,
                    :doc      "",
                    :foreign  true,
                    :generics "",
                    :name     "Time",
                    :native   false,
                    :parent   "",
                    :props    0
                )
            }

            classes = mm.boxed_classes()

            {
                var c = classes[0]

                check_class(
                    classes[-2],
                    :doc      "Test docblock\\n",
                    :foreign  false,
                    :generics "",
                    :name     "Base",
                    :native   true,
                    :parent   "",
                    :props    3
                )
                check_class(
                    classes[-1],
                    :doc      "",
                    :foreign  true,
                    :generics "",
                    :name     "Time",
                    :native   false,
                    :parent   "",
                    :props    0
                )

                if classes.size() != 2: {
                    0 / 0
                }
            }
        """)
    }

    public define test_constant
    {
        var t = Interpreter.with_targets(
            @t_constant_payload
        )

        t.config_set_extra_info(true)

        assert_parse_string(t, """
            import introspect
            import (asdf, ct) _constant
            import _constant

            define check_constant(
                         c: introspect.ConstantEntry,
                :doc   doc: String,
                :line line: Integer,
                :name name: String,
                :type type: String
            )
            {
                var input = <[
                    c.doc(),
                    c.line_number(),
                    c.name(),
                    c.type().as_string()
                ]>
                var expect = <[
                    doc,
                    line,
                    name,
                    type
                ]>

                if input != expect: {
                    raise Exception("\\n    Expected: {0}\\n    Given: {1}"
                            .format(expect, input))
                }
            }

            var mm = introspect.main_module()
            var constant_m = mm.modules_used()[0]
            var constants = constant_m.constants()

            {
                check_constant(
                    constants[-2],
                    :doc       "",
                    :line      4,
                    :name      "asdf",
                    :type      "String"
                )
                check_constant(
                    constants[-1],
                    :doc       "Test docblock\\n",
                    :line      2,
                    :name      "ct",
                    :type      "Integer"
                )
            }

            constants = mm.boxed_constants()

            {
                check_constant(
                    constants[-2],
                    :doc       "Test docblock\\n",
                    :line      2,
                    :name      "ct",
                    :type      "Integer"
                )
                check_constant(
                    constants[-1],
                    :doc       "",
                    :line      4,
                    :name      "asdf",
                    :type      "String"
                )

                if constants.size() != 2: {
                    0 / 0
                }
            }
        """)
    }

    public define test_enum
    {
        var t = Interpreter.with_targets(
            @t_enum_payload
        )

        t.config_set_extra_info(true)

        assert_parse_string(t, """\
            import introspect
            import (FlatOne, FlatEnum) _enum
            import _enum

            define stringify_parameters(p: List[introspect.ParameterEntry])
                : String
            {
                return p.map(|m| "({0},{1},{2})".format(
                    m.name,
                    m.type.as_string(),
                    m.keyword
                )).join()
            }

            define check_enum(
                           e:         introspect.EnumEntry,
                :doc       doc:       String,
                :generics  generics:  String,
                :is_flat   is_flat:   Boolean,
                :is_scoped is_scoped: Boolean,
                :name      name:      String
            )
            {
                var input = <[
                    e.doc(),
                    e.generics().map(|m| m.as_string() ).join(", "),
                    e.is_flat(),
                    e.is_scoped(),
                    e.name()
                ]>
                var expect = <[
                    doc,
                    generics,
                    is_flat,
                    is_scoped,
                    name
                ]>

                if input != expect: {
                    raise Exception("\\n    Expected: {0}\\n    Given: {1}"
                            .format(expect, input))
                }
            }

            define check_enum_method(
                           m:      introspect.MethodEntry,
                :doc       doc:    String,
                :name      name:   String,
                :params    params: String,
                :private   pri:    Boolean,
                :protected pro:    Boolean,
                :public    pub:    Boolean,
                :result    result: String,
                :type      type:   String
            )
            {
                var input = <[
                    m.doc(),
                    m.function_name(),
                    stringify_parameters(m.parameters()),
                    m.is_private(),
                    m.is_protected(),
                    m.is_public(),
                    m.result_type().as_string(),
                    m.type().as_string()
                ]>
                var expect = <[
                    doc,
                    name,
                    params,
                    pri,
                    pro,
                    pub,
                    result,
                    type
                ]>

                if input != expect: {
                    raise Exception("\\n    Expected: {0}\\n    Given: {1}"
                            .format(expect, input))
                }
            }

            define check_variant(
                           v:     introspect.VariantEntry,
                :enum_id   enum_id:   Integer,
                :enum_name enum_name: String,
                :is_empty  is_empty:  Boolean,
                :is_scoped is_scoped: Boolean,
                :params    params:    String,
                :name      name:      String,
                :type      type:      String
            )
            {
                var input = <[
                    v.enum_id(),
                    v.enum_name(),
                    v.is_empty(),
                    v.is_scoped(),
                    stringify_parameters(v.parameters()),
                    v.name(),
                    v.type().as_string()
                ]>
                var expect = <[
                    enum_id,
                    enum_name,
                    is_empty,
                    is_scoped,
                    params,
                    name,
                    type
                ]>

                if input != expect: {
                    raise Exception("\\n    Expected: {0}\\n    Given: {1}"
                            .format(expect, input))
                }
            }

            var mm = introspect.main_module()
            var enum_m = mm.modules_used()[0]
            var enums = enum_m.enums()

            {
                var e = enums[-1]
                var methods = e.methods()
                var variants = e.variants()
                var id = e.id()

                check_enum(
                    e,
                    :doc      "FlatEnum docblock\\n",
                    :generics "",
                    :name     "FlatEnum",
                    :is_flat   true,
                    :is_scoped false
                )

                check_enum_method(
                    methods[-1],
                    :doc        "f docblock\\n",
                    :name       "f",
                    :params     "(,FlatEnum,)(a,Integer,key)",
                    :private    false,
                    :protected  false,
                    :public     true,
                    :result     "Integer",
                    :type       "Function (FlatEnum, Integer => Integer)"
                )

                check_enum_method(
                    methods[-2],
                    :doc        "",
                    :name       "g",
                    :params     "(,FlatEnum,)",
                    :private    false,
                    :protected  false,
                    :public     true,
                    :result     "Unit",
                    :type       "Function (FlatEnum)"
                )

                check_enum_method(
                    methods[-3],
                    :doc        "h docblock\\n",
                    :name       "h",
                    :params     "(,FlatEnum,)",
                    :private    false,
                    :protected  false,
                    :public     true,
                    :result     "Unit",
                    :type       "Function (FlatEnum)"
                )

                check_variant(
                    variants[-1],
                    :enum_id   e.id(),
                    :enum_name e.name(),
                    :is_empty  true,
                    :is_scoped false,
                    :name      "FlatOne",
                    :params    "",
                    :type      "FlatEnum"
                )

                check_variant(
                    variants[-2],
                    :enum_id   e.id(),
                    :enum_name e.name(),
                    :is_empty  false,
                    :is_scoped false,
                    :name      "FlatTwo",
                    :params    "(,Integer,)",
                    :type      "Function (Integer => FlatEnum)"
                )

                check_variant(
                    variants[-3],
                    :enum_id   e.id(),
                    :enum_name e.name(),
                    :is_empty  false,
                    :is_scoped false,
                    :name      "FlatThree",
                    :params    "(,List[String],)",
                    :type      "Function (String... => FlatEnum)"
                )

                check_variant(
                    variants[-4],
                    :enum_id   e.id(),
                    :enum_name e.name(),
                    :is_empty  false,
                    :is_scoped false,
                    :name      "FlatFour",
                    :params    "(,Integer,a)(,String,b)",
                    :type      "Function (Integer, String => FlatEnum)"
                )

                if methods.size() != 3 ||
                   variants.size() != 4: {
                    0 / 0
                }
            }
            {
                var e = enums[-2]
                var methods = e.methods()
                var variants = e.variants()
                var id = e.id()

                check_enum(
                    e,
                    :doc      "",
                    :generics "A, B",
                    :name     "ScopedEnum",
                    :is_flat   false,
                    :is_scoped true
                )

                check_enum_method(
                    methods[-1],
                    :doc        "",
                    :name       "f",
                    :params     "(,ScopedEnum[A, B],)",
                    :private    false,
                    :protected  false,
                    :public     true,
                    :result     "Unit",
                    :type       "Function (ScopedEnum[A, B])"
                )

                check_variant(
                    variants[-1],
                    :enum_id   e.id(),
                    :enum_name e.name(),
                    :is_empty  false,
                    :is_scoped true,
                    :name      "ScopedOne",
                    :params    "(,A,)",
                    :type      "Function (A => ScopedEnum[A, B])"
                )

                check_variant(
                    variants[-2],
                    :enum_id   e.id(),
                    :enum_name e.name(),
                    :is_empty  false,
                    :is_scoped true,
                    :name      "ScopedTwo",
                    :params    "(,B,)",
                    :type      "Function (B => ScopedEnum[A, B])"
                )

                check_variant(
                    variants[-3],
                    :enum_id   e.id(),
                    :enum_name e.name(),
                    :is_empty  true,
                    :is_scoped true,
                    :name      "ScopedThree",
                    :params    "",
                    :type      "ScopedEnum[?, ?]"
                )

                if methods.size() != 1 ||
                   variants.size() != 3: {
                    0 / 0
                }
            }

            enums = mm.boxed_enums()

            {
                var e = enums[-1]
                var variants = mm.boxed_variants()

                check_enum(
                    e,
                    :doc      "FlatEnum docblock\\n",
                    :generics "",
                    :name     "FlatEnum",
                    :is_flat   true,
                    :is_scoped false
                )

                check_variant(
                    variants[-1],
                    :enum_id   e.id(),
                    :enum_name e.name(),
                    :is_empty  true,
                    :is_scoped false,
                    :name      "FlatOne",
                    :params    "",
                    :type      "FlatEnum"
                )

                if enums.size() != 1 ||
                   variants.size() != 1: {
                    0 / 0
                }
            }
        """)
    }

    public define test_define
    {
        var t = Interpreter.with_targets(
            @t_define_payload
        )

        t.config_set_extra_info(true)

        assert_parse_string(t, """\
            import introspect
            import (g) _define
            import _define

            define stringify_parameters(p: List[introspect.ParameterEntry])
                : String
            {
                return p.map(|m| "({0},{1},{2})".format(
                    m.name,
                    m.type.as_string(),
                    m.keyword
                )).join()
            }

            define check_define(
                           f:        introspect.FunctionEntry,
                :doc       doc:      String,
                :generics  generics: String,
                :name      name:     String,
                :params    params:   String,
                :result    result:   String,
                :type      type:     String
            )
            {
                var input = <[
                    f.doc(),
                    f.generics().map(|m| m.as_string() ).join(", "),
                    f.name(),
                    stringify_parameters(f.parameters()),
                    f.result_type().as_string(),
                    f.type().as_string()
                ]>
                var expect = <[
                    doc,
                    generics,
                    name,
                    params,
                    result,
                    type
                ]>

                if input != expect: {
                    raise Exception("\\n    Expected: {0}\\n    Given: {1}"
                            .format(expect, input))
                }
            }

            var mm = introspect.main_module()
            var define_m = mm.modules_used()[0]
            var defines = define_m.functions()

            # Dump __module__ from the top.
            defines.pop()

            check_define(
                defines[-1],
                :doc        "f docblock\\n",
                :generics   "",
                :name       "f",
                :params     "",
                :result     "Unit",
                :type       "Function ()"
            )

            check_define(
                defines[-2],
                :doc        "",
                :generics   "",
                :name       "g",
                :params     "(a,Integer,)",
                :result     "String",
                :type       "Function (Integer => String)"
            )

            check_define(
                defines[-3],
                :doc        "",
                :generics   "",
                :name       "h",
                :params     "(b,List[Double],)",
                :result     "Unit",
                :type       "Function (Double...)"
            )

            check_define(
                defines[-4],
                :doc        "",
                :generics   "",
                :name       "i",
                :params     "(c,*String,)",
                :result     "Unit",
                :type       "Function (*String)"
            )

            if defines.size() != 4: {
                0 / 0
            }

            defines = mm.boxed_functions()

            check_define(
                defines[-1],
                :doc        "",
                :generics   "",
                :name       "g",
                :params     "(a,Integer,)",
                :result     "String",
                :type       "Function (Integer => String)"
            )

            if defines.size() != 1: {
                0 / 0
            }
        """)
    }

    public define test_module
    {
        var t = Interpreter.with_targets(
            @t_nest_example,
            @t_fake
        )

        # module entry (setup)

        assert_parse_string(t, """
            import introspect
            import "nest/example"
            import fake
            import (Time) time

            define check_module(
                         m:       introspect.ModuleEntry,
                :dirname dirname: String,
                :name    name:    String
            )
            {
                var input = <[
                    m.dirname(),
                    m.name()
                ]>
                var expect = <[
                    dirname,
                    name
                ]>

                if input != expect: {
                    raise Exception("\\n    Expected: {0}\\n    Given: {1}"
                            .format(expect, input))
                }
            }

            var main_m = introspect.main_module()
            var modules = main_m.modules_used()

            {
                check_module(
                    modules[-3],
                    :dirname "packages\\/fake\\/src",
                    :name    "fake"
                )

                check_module(
                    modules[-2],
                    :dirname "",
                    :name    "example"
                )

                check_module(
                    modules[-1],
                    :dirname "",
                    :name    "introspect"
                )

                if modules.size() != 3: {
                    0 / 0
                }
            }
        """)
    }

    public define test_toplevel
    {
        var t = Interpreter()

        # toplevel (introspect.class_name)

        assert_parse_string(t, """
            import (Random) random
            import (Coroutine) coroutine
            import (class_name) introspect

            define f(co: Coroutine[Integer, Unit]): Integer {
                return 0
            }

            var result = [
                1                  |> class_name,
                1.0                |> class_name,
                "1"                |> class_name,
                '1'                |> class_name,
                B"1"               |> class_name,
                true               |> class_name,
                [1]                |> class_name,
                [1 => 1]           |> class_name,
                <[1]>              |> class_name,
                unit               |> class_name,
                stdout             |> class_name,
                Exception("")      |> class_name,
                ValueError("")     |> class_name,
                Coroutine.build(f) |> class_name,
                Some(1)            |> class_name,
                Random()           |> class_name,
            ]

            var expect = [
                "Integer",
                "Double",
                "String",
                "Byte",
                "ByteString",
                "Boolean",
                "List",
                "Hash",
                "Tuple",
                "Unit",
                "File",
                "Exception",
                "ValueError",
                "Coroutine",
                "Some",
                "Random",
            ]

            if result != expect: {
                0 / 0
            }
        """)
    }

    public define test_var
    {
        var t = Interpreter.with_targets(
            @t_var_payload
        )

        t.config_set_extra_info(true)

        assert_parse_string(t, """\
            import introspect
            import (one) _var
            import _var

            define check_var(
                           v:    introspect.VarEntry,
                :doc       doc:  String,
                :name      name: String,
                :type      type: String
            )
            {
                var input = <[
                    v.doc(),
                    v.name(),
                    v.type().as_string()
                ]>
                var expect = <[
                    doc,
                    name,
                    type
                ]>

                if input != expect: {
                    raise Exception("\\n    Expected: {0}\\n    Given: {1}"
                            .format(expect, input))
                }
            }

            var mm = introspect.main_module()
            var var_m = mm.modules_used()[0]
            var vars = var_m.vars()

            check_var(
                vars[-1],
                :doc        "Var docblock\\n",
                :name       "one",
                :type       "Integer"
            )

            check_var(
                vars[-2],
                :doc        "",
                :name       "two",
                :type       "String"
            )

            if vars.size() != 2: {
                0 / 0
            }

            vars = mm.boxed_vars()

            check_var(
                vars[-1],
                :doc        "Var docblock\\n",
                :name       "one",
                :type       "Integer"
            )

            if vars.size() != 1: {
                0 / 0
            }
        """)
    }
}
