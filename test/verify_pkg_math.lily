import test
import math

var t = test.t

t.scope(__file__)

# compare two double precision floats with a small delta value since
# a computer will rarely see sin(pi) as 0
define fequals(x: Double, y: Double): Boolean {
    var delta = 0.0000001
    if x == 0.0 && y == 0.0: {
        return true
    }
    return (x - y) / y < delta
}

# Test for correctness

t.assert("math.abs with valid input.",
    (||
        math.abs(-34) == 34
    )
)

t.assert("math.acos with valid input.",
    (||
        fequals(math.acos(math.pi / 4.0), 0.6674572160283838)
    )
)

t.assert("math.asin with valid input.",
    (||
        fequals(math.asin(math.pi / 4.0), 0.9033391107665127)
    )
)

t.assert("math.atan with valid input.",
    (||
        fequals(math.atan(math.pi / 4.0), 0.6657737500283538)
    )
)

t.assert("math.ceil with valid input.",
    (||
        fequals(math.ceil(23.4), 24.0)
    )
)

t.assert("math.cos with valid input.",
    (||
        fequals(math.cos(math.pi), -1.0)
    )
)

t.assert("math.cosh with valid input.",
    (||
        fequals(math.cosh(math.pi), 11.591953275521519)
    )
)

t.assert("math.exp with valid input.",
    (||
        fequals(math.exp(3.0), 20.085536923187668)
    )
)

t.assert("math.fabs with valid input.",
    (||
        fequals(math.fabs(-3.0), 3.0)
    )
)

t.assert("math.floor with valid input.",
    (||
        fequals(math.floor(23.4), 23.0)
    )
)

t.assert("math.fmod with valid input.",
    (||
        fequals(math.fmod(3.0, 2.0), 1.0)
    )
)

t.assert("math.ldexp with valid input.",
    (||
        fequals(math.ldexp(5.0, 4), 80.0)
    )
)

t.assert("math.log with valid input.",
    (||
        fequals(math.log(math.exp(1.0)), 1.0)
    )
)

t.assert("math.log10 with valid input.",
    (||
        fequals(math.log10(10.0), 1.0)
    )
)

t.assert("math.modf with valid input.",
    (||
        var ip_fp = math.modf(23.4)

        fequals(ip_fp[0], 23.0) && fequals(ip_fp[1], 0.4)
    )
)

t.assert("math.pow with valid input.",
    (||
        fequals(math.pow(2.0, 5.0), 32.0)
    )
)

t.assert("math.sin with valid input.",
    (||
        fequals(math.sin(math.pi / 2.0), 1.0)
    )
)

t.assert("math.sinh with valid input.",
    (||
        fequals(math.sinh(math.pi / 2.0), 2.3012989023072947)
    )
)

t.assert("math.sqrt with valid input.",
    (||
        fequals(math.sqrt(25.0), 5.0)
    )
)

t.assert("math.tan with valid input.",
    (||
        fequals(math.tan(math.pi / 8.0), 0.41421356237309503)
    )
)

t.assert("math.tanh with valid input.",
    (||
        fequals(math.tanh(math.pi / 8.0), 0.3736847479012153)
    )
)

t.assert("math.to_deg with valid input.",
    (||
        fequals(math.to_deg(math.pi), 180.0)
    )
)

t.assert("math.to_rad with valid input.",
    (||
        fequals(math.to_rad(180.0), math.pi)
    )
)

# Test error reporting

t.assert("math.pow returns infinity on a codomain error.",
    (||
        math.is_infinity(math.pow(999999.0, 99999.0))
    )
)

t.assert("math.sqrt returns nan on a domain error.",
    (||
        math.is_nan(math.sqrt(-1.0))
    )
)
