import test

var t = test.t

t.scope(__file__)

t.interpret("Cover use of an imported flat enum.",
    """
    import (FlatEnum, FlatOne, FlatTwo, FlatThree) covlib

    var v = "" ++ FlatTwo
    if v != "FlatTwo": {
        raise Exception("Failed to interpolate.")
    }

    define f(l: List[FlatEnum]): List[Integer] {
        var result: List[Integer] = []

        for i in 0...l.size() - 1: {
            var e = l[i]
            match e: {
                case FlatOne:
                    result.push(1)
                case FlatTwo:
                    result.push(2)
                case FlatThree:
                    result.push(3)
            }
        }

        return result
    }

    var v2 = f([FlatOne, FlatTwo, FlatThree, FlatTwo, FlatOne])
    if v2 != [1, 2, 3, 2, 1]: {
        raise Exception("Failed to match and transform.")
    }
    """)

t.interpret("Cover use of an imported scoped enum.",
    """
    import (ScopedEnum) covlib

    var v = "" ++ ScopedEnum.ScopedTwo
    if v != "ScopedEnum.ScopedTwo": {
        raise Exception("Failed to interpolate.")
    }

    define f(l: List[ScopedEnum]): List[Integer] {
        var result: List[Integer] = []

        for i in 0...l.size() - 1: {
            var e = l[i]
            match e: {
                case ScopedEnum.ScopedOne:
                    result.push(1)
                case ScopedEnum.ScopedTwo:
                    result.push(2)
                case ScopedEnum.ScopedThree:
                    result.push(3)
            }
        }

        return result
    }

    var v2 = f([ScopedEnum.ScopedThree, ScopedEnum.ScopedOne, ScopedEnum.ScopedTwo])
    if v2 != [3, 1, 2]: {
        raise Exception("Failed to match and transform.")
    }
    """)

t.interpret("Cover using covlib to do extra api tests.",
    """
    import covlib

    covlib.cover_list_reserve()
    if covlib.cover_func_check((|x| 10 ), Integer.to_s) == false: {
        raise Exception("cover_func_check failed.")
    }
    covlib.cover_list_sfs()

    define f(co: Coroutine[Integer, Integer]): Integer {
        return 1
    }

    class Example < Exception("") {

    }

    var co = Coroutine.build(f)

    if covlib.cover_id_checks(co, unit, covlib.Container(""), "abc") == false: {
        raise Exception("cover_id_checks failed.")
    }

    define co_base(local_co: Coroutine[Integer, Integer]): Integer { return 0 }
    define f2(a: Integer) {}

    # Avoid creating another Coroutine by using the same one twice.
    var saved_co = Coroutine.build(co_base)

    covlib.cover_value_as('a',
                          B"123",
                          Exception("test"),
                          saved_co,
                          1.0,
                          stdout,
                          f2,
                          [1 => 1],
                          1,
                          "1")

    if covlib.cover_value_group(true,
                                '1',
                                B"1",
                                saved_co,
                                1.0,
                                None,
                                stdout,
                                f2,
                                [1 => 1],
                                covlib.Foreign(),
                                Exception("x"),
                                1,
                                [1],
                                "1",
                                <[1]>,
                                unit,
                                Some(1)) == false: {
        raise Exception("cover_value_group failed.")
    }

    covlib.cover_ci_from_native(f2)
    covlib.cover_misc_api()
    """)

t.interpret("Cover inheriting from foreign-based native class.",
    """
    import covlib

    class InheritedContainer(x: String) < covlib.Container(x) {
        public define do_update(y: String) {
            update(y ++ y)
        }
    }

    var i = InheritedContainer("abc")
    i.do_update("xyz")

    if i.fetch() != "xyzxyz": {
        raise Exception("failed")
    }
    """)

t.interpret("Cover lily_optional_* functions.",
    """
    import covlib

    var b_values = [
        <["A, B, C", 0, covlib.cover_optional_boolean(false, false, false)]>,
        <["A, B, _", 1, covlib.cover_optional_boolean(false, false)]>,
        <["A, _, C", 1, covlib.cover_optional_boolean(false, :c false)]>,
        <["A, _, _", 2, covlib.cover_optional_boolean(false)]>,
        <["_, B, C", 1, covlib.cover_optional_boolean(:b false, :c false)]>,
        <["_, B, _", 2, covlib.cover_optional_boolean(:b false)]>,
        <["_, _, C", 2, covlib.cover_optional_boolean(:c false)]>,
        <["_, _, _", 3, covlib.cover_optional_boolean()]>,
    ]

    var i_values = [
        <["A, B, C", 6, covlib.cover_optional_integer(1, 2, 3)]>,
        <["A, B, _", 303, covlib.cover_optional_integer(1, 2)]>,
        <["A, _, C", 204, covlib.cover_optional_integer(1, :c 3)]>,
        <["A, _, _", 501, covlib.cover_optional_integer(1)]>,
        <["_, B, C", 105, covlib.cover_optional_integer(:b 2, :c 3)]>,
        <["_, B, _", 402, covlib.cover_optional_integer(:b 2)]>,
        <["_, _, C", 303, covlib.cover_optional_integer(:c 3)]>,
        <["_, _, _", 600, covlib.cover_optional_integer()]>,
    ]

    var s_values = [
        <["A, B, C", "123", covlib.cover_optional_string("1", "2", "3")]>,
        <["A, B, _", "12",  covlib.cover_optional_string("1", "2")]>,
        <["A, _, C", "13",  covlib.cover_optional_string("1", :c "3")]>,
        <["A, _, _", "1",   covlib.cover_optional_string("1")]>,
        <["_, B, C", "23",  covlib.cover_optional_string(:b "2", :c "3")]>,
        <["_, B, _", "2",   covlib.cover_optional_string(:b "2")]>,
        <["_, _, C", "3",   covlib.cover_optional_string(:c "3")]>,
        <["_, _, _", "",    covlib.cover_optional_string()]>,
    ]

    define check_table[A, B](source: List[Tuple[A, B, B]]) {
        for i in 0...source.size() - 1: {
            var v = source[i]

            if v[1] != v[2]: {
                raise Exception("Test '{0}' failed (want {1}, have {2})."
                        .format(v[0], v[1], v[2]))
            }
        }
    }

    check_table(b_values)
    check_table(i_values)
    check_table(s_values)
    """)
