# This script updates the interpreter's prelude (src/lily_pkg_core.c).
#
# Adding new modules to the interpreter is uncommon enough that it's easy to
# forget one of the steps. This script updates the prelude so that the parser is
# able to find the modules and their symbols.
#
# Here is a full list of the steps needed to add a new module to the prelude.
#
# * Create the module file. Modules in the prelude are expected to be in the
#   `src` directory. The module's name should be `lily_pkg_<name>.c`.
#
# * After adding symbols, use bindgen to create the module's binding file. The
#   module file must be updated to include the binding file and to invoke
#   the initialization found within the binding file.
#
# * Add the module's name to `targets` right below this comment and run this
#   script. This script will reload cmake after updating files.
#
# * Add module tests in `test/prelude/test_pkg_<name>.lily` and run the test
#   suite.
#
# Once the module has been added and properly tested, the website documentation
# should be updated. However, this checklist does not cover that since the
# website documentation is located in a different repository.

import subprocess

var targets = [
    "prelude",
    "coroutine",
    "fs",
    "introspect",
    "math",
    "random",
    "subprocess",
    "sys",
    "time",
]

define generate_c_header: String
{
    var result = """\
#include "lily.h"
#include "lily_vm.h"

/* This file is automatically generated by scripts/prelude.lily. */\
"""

    return result
}

define generate_info_tables: String
{
    var data = targets.map(|t|
            var f = "extern const char *lily_{0}_info_table[];"
            f.format(t)
        ).join("\n")

    return data
}

define generate_call_tables: String
{
    var data = targets.map(|t|
            var f = "extern lily_call_entry_func lily_{0}_call_table[];"
            f.format(t)
        ).join("\n")

    return data
}

define generate_bootstrap: String
{
    var data = targets.map(|t|
        var info = "lily_" ++ t ++ "_info_table"
        var call = "lily_" ++ t ++ "_call_table"
        var f = "    lily_module_register(vm, \"{0}\", {1}, {2});"

        f.format(t, info, call)
    ).join("\n")

    var result = """\
void lily_prelude_register(lily_vm_state *vm)
{
%data%
}
""".replace("%data%", data)

    return result
}

define generate_prelude_c_file
{
    var steps = [
        generate_c_header,
        generate_info_tables,
        generate_call_tables,
        generate_bootstrap,
    ]
    var output = steps.map(|m| m() )
                      .join("\n\n")
    var path = "src/lily_pkg_core.c"
    var f = File.open(path, "w")

    f.write(output)
    f.close()

    var message = "Updated the prelude file at '{0}'.".format(path)

    print(message)
}

define generate_manifest_header: String
{
    var result = """\
import manifest

# This file is automatically generated by scrips/prelude.lily.

### Pseudo root of all pre-registered modules.
###
### This is a fake module created to link together all of the modules that are
### automatically loaded in the interpreter.
###
### Except for the `prelude` module, all modules listed here can be imported
### from any file inside of the interpreter. This is unlike other modules, which
### are loaded using relative paths.
###
### The `prelude` module is unique because the classes, enums, and functions are
### the foundation of the interpreter. Instead of requiring it to be imported,
### the contents of `prelude` are instead available without a namespace.
library core\
"""

    return result
}

define generate_manifest_imports: String
{
    var result = targets.map(|t| "import pkg_" ++ t )
                        .join("\n")
                        ++ "\n"

    return result
}

define generate_prelude_manifest
{
    var steps = [
        generate_manifest_header,
        generate_manifest_imports,
    ]
    var output = steps.map(|m| m() )
                      .join("\n\n")
    var path = "manifest/pkg_core.lily"
    var f = File.open(path, "w")

    f.write(output)
    f.close()
    print("Updated core manifest file at '{0}'.".format(path))
}

define update_cmake_file
{
    print("Reloading cmake.")

    var pipe = subprocess.popen("cmake .")

    pipe.read().encode().unwrap() |> print
    pipe.close()
}

generate_prelude_manifest()
generate_prelude_c_file()
update_cmake_file()
